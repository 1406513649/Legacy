#!/usr/bin/python

#
# The Specialized HIstory Viewer reads and views ASCII files containing
# history data from scientific simulation applications.  The data is
# specialized to tracer points, material globals, and other mesh global data.
#
# This script should run out of the box on most platforms, however, see the
# REQUIREMENTS section of the man page below if it does not.
#

import os, sys
import re, string
import math
import getopt
import time
import array

version = "1.76"

manpage = \
"""
NAME
      shiv - Specialized HIstory Viewer (version """ + version + """)

SYNOPSIS
      shiv [OPTIONS] [datafile [...] ]

      If files are given, they are read in at start up time.

DESCRIPTION
      The shiv script reads history data files and shows X-Y plots of the data
      they contain.  There is a specialized native ASCII format, but it can
      also read other formats such as Exodus and binary HISPLT.

      See the online help manual for more information about shiv.

OPTIONS
      -h, --help
           Print man page and exit.
      -V, --version
           Print version number and exit

      -L   Use long filenames.  Normally only the basename is used in the
           legend and file buttons.  This switch uses whatever is on the
           command line.

      --txt
           Treat the input files as tabular text.
      --exodus
           Treat file(s) as an Exodus file for reading.
      --his
           Treat file(s) as a binary HISPLT file for reading.
      --histoa
           Force the histoa program to be run on input files for reading.

      --skip <integer>
           During file reads, take every n-th data point.  This allows really
           big files to be trimmed down for viewing and batch extraction.

      --yzclip ymin[/ymax[/zmin[/zmax]]]
           In spatial profile mode, this creates a rectangle in the yz plane
           and only points within the rectangle will be shown.  In 2D, zmin
           and zmax are ignored.  Values subsequent to ymin are optional, and
           if not given are set to the limits of the geometry.

      -b, --batch
           Run shiv in batch mode.  This causes shiv to extract variables from
           the file and dump to standard out in one of the ASCII output
           formats.  By default, all history variables are selected for export,
           but specific variables can be selected by using the options below.
           The ASCII format is comma separated values by default but a
           different one can be selected using --csv, --tab or --xmgr.

      -p, --point <point id/variable name>
           For batch mode, this point id and variable name is selected for
           export.
      -m, --material <material id/variable name>
           For batch mode, this material id and variable name is selected for
           export.
      -g, --global <variable name>
           For batch mode, this global variable name is selected for export.

      -t, --time <float>
           For batch mode, the time plane closest to the given value will be
           selected for export.
      -i, --output-index <int>
           For batch mode, the time plane with the given 0-based index will be
           selected for export.  A value of -1 will select the last time plane.
      -c, --cycle-index <int>
           For batch mode, the time plane with the closest 0-based cycle index
           will be selected for export.  A -1 will select the last time plane.
      -e, --element <variable name>
           For batch mode, this element variable name is selected for export.
      -d, --edge <variable name>
           For batch mode, this edge variable name is selected for export.
      -f, --face <variable name>
           For batch mode, this face variable name is selected for export.
      -n, --node <variable name>
           For batch mode, this node variable name is selected for export.
      --xelements
          For batch mode, extract all element variables.
      --xedges
          For batch mode, extract all edge variables.
      --xfaces
          For batch mode, extract all face variables.
      --xnodes
          For batch mode, extract all node variables.

      --tab
           For batch mode, export in tabular text format.  This is the default
           if a format is not specified.
      --csv
           For batch mode, export in comma separated values format.
      --xmgr
           For batch mode, export in xmgr ASCII format.  This is the only
           output format that can handle multiple files in a single plot.
      --nolabels
           For batch mode with tabular or comma separated values format, do
           not print labels or units.

REQUIREMENTS
      The shiv script uses any version of python that is built with Tkinter.
      The Tkinter module is a wrapper around the tcl/tk libraries, which are
      highly portable.  Nearly every Linux distribution has the tcl/tk
      libraries and python built against them.  For other platforms, it
      depends on how python was built and installed.

      The bottom line is that this script will most likely run out-of-the-box
      on most platforms, especially Linux distributions.  If not, read below
      about building tcl/tk and python.

      In order to read binary CTH HISPLT formatted files with the histoa
      program, the histoa program must be in your path.  Using histoa is not
      necessary (any more) because there is a pure python reader in this
      script.  Note that .his files are fortran binary files and can only be
      read by histoa on the same platform on which the .his file was written
      (or a similar enough platform).

      In order to read Exodus II global variables, the ncdump program packaged
      with NetCDF must be in your path.  Note that Exodus files are platform
      portable.

      Building tcl/tk and python:

      If your version of python was not built with the tcl/tk libraries, the
      shiv script can be used to build and install tcl, tk, then python.  You
      can check whether a python binary was built with tcl/tk and is functional
      by first, making sure your DISPLAY environment variable is set correctly,
      then running python without any arguments.  When the command line comes
      up, issue

        >>> import Tkinter
        >>> Tkinter._test()

      A little window should come up on which you can click buttons.

      If your python was not installed with tcl/tk or is not functional, you
      first need to download a tcl/tk pair (say version 8.4) and a python
      version (say 2.3 or greater).  Uncompress and untar all three in the
      same current working directory (using gunzip or bunzip2 and tar xvf).
      Then run

          shiv --install --prefix=/install/path [ tcldir tkdir pythondir ]

      where the install path is where you want to install the resulting
      libraries and executables.  The directory names are optional and are
      needed if this script cannot figure out the correct names of the
      unpacked source code.

AUTHORS
      Richard Drake, Sandia National Laboratories, rrdrake@sandia.gov
"""


############################################################################

for a in sys.argv[1:]:
  if a == '-h' or a == '--help' or a == '-help':
    print manpage
    sys.exit(0)
  elif a == '-V' or a == '--version':
    print version
    sys.exit(0)


# these are used for defining the variable types
POINTID        = 0
POINTVAR       = 1
MATID          = 2
MATVAR         = 3
GLOBVAR        = 4
POINTVAR_UNITS = 5
MATVAR_UNITS   = 6
GLOBVAR_UNITS  = 7

NODE = 0
EDGE = 1
FACE = 2
ELEM = 3
TIME = 4
CYCLE = 5  # only for batchSelect
INDEX = 6  # only for batchSelect

# used to try to avoid certain floating point operation errors
SMALL_FLOAT = 1.e-30
SMALL_POWER = -30

# data view enums
DATAVIEW_HISTORY = 0
DATAVIEW_PROFILE = 1
DATAVIEW_POINTS = 2

haveexodus = 0
yzclip = None

############################################################################

def quoted_tokenize(line,sep=' \t\r\n'):
    """
    Tokenizes a string using the given separator (defaulting to whitespace)
    and taking care to treat characters inside of quotes as a single token.
    """
    inquote = 0
    tok = ""
    L = []
    for c in line:
      if c == '"':
        if inquote:
          inquote = 0
          L.append(tok)
          tok = ""
        else:
          inquote = 1
      elif inquote:
        tok = tok + c
      elif c in sep:
        if tok:
          L.append(tok)
          tok = ""
      else:
        tok = tok + c
    if tok:
      L.append(tok)

    return L


class ProfileSegment:
    """
    Utility class for reading spatially varying data (mesh data).
    """
    def __init__(self, Lidx, Ridx, points):
        self.Lidx = Lidx
        self.Ridx = Ridx
        self.points = points
        self.Lseg = None
        self.Rseg = None
    def divide(self, slot):
        D = self.points[self.Ridx][slot] - self.points[self.Lidx][slot]
        dmax = 0.0
        idx = None
        i = self.Lidx
        while i < self.Ridx:
          d = self.points[i+1][slot] - self.points[i][slot]
          if d > dmax:
            dmax = d; idx = i
          i = i + 1
        if idx != None and dmax > float(D/10.0):
          self.Lseg = ProfileSegment( self.Lidx, idx, self.points )
          self.Rseg = ProfileSegment( idx+1, self.Ridx, self.points )
          self.Lseg.divide(slot)
          self.Rseg.divide(slot)
    def gather(self, L):
        if self.Lseg != None:
          assert self.Rseg != None
          self.Lseg.gather(L)
          self.Rseg.gather(L)
        else:
          L.append( (self.Lidx, self.Ridx) )


class FileData:

    def __init__(self, filename,skipval=None):

        self.title = ''
        self.filename = filename
        self.mergefiles = []
        self.idstring = filename
        self.skipval = skipval

        # make this false to avoid removing duplicates
        self.nodups = 1

        # indexed by POINTID, POINTVAR, MATID, MATVAR, GLOBVAR,
        # POINTVAR_UNITS, MATVAR_UNITS, GLOBVAR_UNITS;  the lists contain ids
        # and variable names for each type of data; the point ids are actually
        # pairs of (id,type)
        self.vars = [ [], [], [], [], [], [], [], [] ]

        self.cycles = []
        self.times = []
        self.timesteps = []
        self.cputimes = []

        # each entry is a list of length len(self.vars[POINTID])
        # and each of those a list of length len(self.vars[POINTVAR])
        self.point_values = []

        # each entry is a list of length len(self.vars[MATID])
        # and each of those a list of length len(self.vars[MATVAR])
        self.mat_values = []

        # each entry is a list of length len(self.vars[GLOBVAR])
        self.glob_values = []

        self.geom = 0  # false
        self.exoapi = None

        errstr = self._readFile(filename)
        if errstr:
          raise IOError, errstr

    def setIdentifier(self, idstring):
        self.idstring = idstring

    def identifier(self):
        return self.idstring

    def mergeFile(self, filename):
        """
        Reads the given filename and appends the data onto the existing data
        at the overlapping time value.  The overlap data from the first file
        is dropped.
        """
        fd = FileData(filename, opts.get('--skip',None))
        if len(self.times) == 0:
          self.vars = fd.vars
          self.cycles = fd.cycles
          self.times = fd.times
          self.timesteps = fd.timesteps
          self.cputimes = fd.cputimes
          self.point_values = fd.point_values
          self.mat_values = fd.mat_values
          self.glob_values = fd.glob_values
        elif len(fd.times) > 0:
          for h in [ POINTID, POINTVAR, MATID, MATVAR, GLOBVAR ]:
            if self.vars[h] != fd.vars[h]:
              raise IOError( "merge file, " + filename + ", does not have " + \
                 "the same variables as the first file, " + self.filename )
          cL = []; tL = []; tsL = []; cpuL = []
          pL = []; mL = []; gL = []
          for i in range(len(self.times)):
            t = self.times[i]
            if t < fd.times[0]:
              cL.append( self.cycles[i] )
              tL.append(t)
              tsL.append( self.timesteps[i] )
              cpuL.append( self.cputimes[i] )
              pL.append( self.point_values[i] )
              mL.append( self.mat_values[i] )
              gL.append( self.glob_values[i] )
            else:
              break
          for i in range(len(fd.times)):
            cL.append( fd.cycles[i] )
            tL.append( fd.times[i] )
            tsL.append( fd.timesteps[i] )
            cpuL.append( fd.cputimes[i] )
            pL.append( fd.point_values[i] )
            mL.append( fd.mat_values[i] )
            gL.append( fd.glob_values[i] )
          self.cycles = cL
          self.times = tL
          self.timesteps = tsL
          self.cputimes = cpuL
          self.point_values = pL
          self.mat_values = mL
          self.glob_values = gL
        self.mergefiles.append(filename)

    def reread(self):
        if self.exoapi != None:
          self.exoapi.closefile()
          self.exoapi = None
        if not os.path.exists( self.filename ):
          raise IOError, "file does not exist: " + self.filename
        mf = self.mergefiles
        self.mergefiles = []
        self.title = ''
        self.vars = [ [], [], [], [], [], [], [], [] ]
        self.cycles = []
        self.times = []
        self.timesteps = []
        self.cputimes = []
        self.point_values = []
        self.mat_values = []
        self.glob_values = []
        errstr = self._readFile(self.filename)
        if errstr:
          raise IOError, errstr
        for f in mf:
          self.mergeFile(f)

    def getList(self, var_type):
        """
        Use POINTID, POINTVAR, POINTVAR_UNITS, MATID, MATVAR, MATVAR_UNITS,
        GLOBVAR, or GLOBVAR_UNITS.  Returns a list of (id,type) for POINTID,
        ids for MATID, and string names for others.
        """
        return self.vars[var_type]

    def getUnitsList(self, var_type):
        """
        Use POINTVAR, MATVAR, or GLOBVAR.  Returns a list of unit strings for
        the given variable type.
        """
        if var_type == POINTVAR:
          return self.vars[POINTVAR_UNITS]
        elif var_type == MATVAR:
          return self.vars[MATVAR_UNITS]

        assert var_type == GLOBVAR, \
               "var_type must be POINTVAR, MATVAR, or GLOBVAR"
        return self.vars[GLOBVAR_UNITS]

    def getTimeValues(self):
        return self.times

    def getCycles(self):
        """
        Returns a list of the cycle numbers for each time dump.
        """
        return self.cycles

    def getValues(self, var_type, var_index, id_index=None):
        """
        The var_type can be POINTVAR, MATVAR, and GLOBVAR.
        The id_index must be supplied for POINTVAR and MATVAR.
        Returns a list of variable values of the given type of data for the
        given variable index for the given id index over all time steps.
        """
        if var_type == POINTVAR:
          assert id_index >= 0 and id_index < len(self.vars[POINTID])
          assert var_index >= 0 and var_index < len(self.vars[POINTVAR])
          vals = []
          for pL in self.point_values:
            vals.append( pL[id_index][var_index] )
          return vals
        elif var_type == MATVAR:
          assert id_index >= 0 and id_index < len(self.vars[MATID])
          assert var_index >= 0 and var_index < len(self.vars[MATVAR])
          vals = []
          for mL in self.mat_values:
            vals.append( mL[id_index][var_index] )
          return vals
        assert var_type == GLOBVAR
        assert var_index >= 0 and var_index < len(self.vars[GLOBVAR])
        vals = []
        for gL in self.glob_values:
          vals.append( gL[var_index] )
        return vals

    #########################################################################

    def hasGeometry(self):
        return self.geom

    def getVarNames(self, var_type):
        assert self.exoapi != None
        if var_type == NODE: return self.exoapi.varNames(exodus.EX_NODE)
        if var_type == EDGE: return self.exoapi.varNames(exodus.EX_EDGE)
        if var_type == FACE: return self.exoapi.varNames(exodus.EX_FACE)
        if var_type == ELEM: return self.exoapi.varNames(exodus.EX_ELEM)
        assert var_type == NODE or var_type == EDGE or \
               var_type == FACE or var_type == ELEM

    def getXlines(self):
        """
        Collect nodes, edges, faces and elements into lists of ordered object
        indexes which are lines in the X direction.
        """
        nL = []
        gL = []
        fL = []
        eL = []

        if self.exoapi.getDimension() > 1:

          numnodes = self.exoapi.getNumber( exodus.EX_NODE )
          coords = self.exoapi.readCoords()
          assert numnodes == len(coords[0])
          coordsx = coords[0]
          coordsy = coords[1]
          if self.exoapi.getDimension() > 2: coordsz = coords[2]

          if yzclip != None:
            diam = max(coordsy)-min(coordsy)
            if yzclip[1] == None: yzclip[1] = max(coordsy) + 0.0001*diam
            if self.exoapi.getDimension() > 2:
              diam = max(coordsz)-min(coordsz)
              if yzclip[2] == None: yzclip[2] = min(coordsz) - 0.0001*diam
              if yzclip[3] == None: yzclip[3] = min(coordsz) + 0.0001*diam

          def parts( pointL, slot ):
              """
              Local scope function to sort and partition a list using 'slot'
              to index each entry of 'pointL'.  That is, it is sorted on
              pointL[slot].
              """
              nL = []

              if len(pointL) > 0:

                pointL.sort( lambda x, y, i=slot: cmp(x[i],y[i]) )

                # divide the nodes into partitions based on the y coordinates
                seg = ProfileSegment( 0, len(pointL)-1, pointL )
                seg.divide(slot)
                partitionL = []
                seg.gather(partitionL)

                # create separate lists of nodes from each of the partitions
                for i,j in partitionL:
                  segL = []
                  k = i
                  while k <= j:
                    segL.append( pointL[k] )
                    k = k + 1
                  segL.sort()
                  nL.append( segL )

              return nL

          # elements, faces, edges are partitioned by center
          blkL = []
          for btype,k in [ (exodus.EX_ELEM_BLOCK,0),
                           (exodus.EX_FACE_BLOCK,1),
                           (exodus.EX_EDGE_BLOCK,2) ]:
            points = []
            bidL = self.exoapi.getIds(btype)
            for bid in bidL:
              cnt = self.exoapi.getBlock( btype, bid )[1]
              centers = self.exoapi.computeCenters( btype, bid, coords )
              if yzclip == None:
                for e in range(cnt):
                  points.append( (centers[0][e], centers[1][e], bid, e) )
              elif self.exoapi.getDimension() == 2:
                for e in range(cnt):
                  y = centers[1][e]
                  if y > yzclip[0] and y < yzclip[1]:
                    points.append( (centers[0][e], centers[1][e], bid, e) )
              else:
                for e in range(cnt):
                  y = centers[1][e]
                  z = centers[2][e]
                  if y > yzclip[0] and y < yzclip[1] and \
                     z > yzclip[2] and z < yzclip[3]:
                    points.append( (centers[0][e], centers[1][e], bid, e) )
            blkL.append( parts( points, 1 ) )

          eL = blkL[0]
          fL = blkL[1]
          gL = blkL[2]

          # partition the nodes
          points = []
          if yzclip == None:
            for n in range(numnodes):
              points.append( (coordsx[n],coordsy[n],n) )
          elif self.exoapi.getDimension() == 2:
            for n in range(numnodes):
              y = coordsy[n]
              if y > yzclip[0] and y < yzclip[1]:
                points.append( (coordsx[n],coordsy[n],n) )
          else:
            for n in range(numnodes):
              y = coordsy[n]
              z = coordsz[n]
              if y > yzclip[0] and y < yzclip[1] and \
                 z > yzclip[2] and z < yzclip[3]:
                points.append( (coordsx[n],coordsy[n],n) )
          nL = parts( points, 1 )

          points = None

        return nL, gL, fL, eL

    def getGeomValues(self, time_idx, var_type, var_index, blk_id):
        """
        Gets an array.array of floating point values for a given variable
        at the given 0-based time step index.  The var_type can be ELEM, FACE,
        EDGE, or NODE.  The blk_id is not used for NODE variables.
        """
        if   var_type == NODE: var_type = exodus.EX_NODE
        elif var_type == EDGE: var_type = exodus.EX_EDGE
        elif var_type == FACE: var_type = exodus.EX_FACE
        elif var_type == ELEM: var_type = exodus.EX_ELEM
        a = self.exoapi.readVar( time_idx+1, var_type, blk_id, var_index )
        return a

    def getDispl(self, time_idx, var_type, blk_id):
        """
        Gets an array.array containing the displacements for NODE, EDGE,
        FACE, or ELEM at the given 0-based time step index.  For all but NODE,
        the displacements are arithmetic averages of the displacements on the
        nodes.
        """
        if   var_type == NODE: var_type = exodus.EX_NODE
        elif var_type == EDGE: var_type = exodus.EX_EDGE
        elif var_type == FACE: var_type = exodus.EX_FACE
        elif var_type == ELEM: var_type = exodus.EX_ELEM

        if not hasattr(self,'displx'):
          # cache the index of the displacement variable
          self.displx = self.exoapi.findVar( exodus.EX_NODE, "DISPLX" )

        disp = array.array( self.exoapi.storageType() )
        if self.displx != None:
          self.exoapi.readVar( time_idx+1, exodus.EX_NODE,
                               blk_id, self.displx, disp )
        elif var_type == exodus.EX_NODE:
          nnodes = self.exoapi.getNumber(exodus.EX_NODE)
          exodus.resize_array( disp, nnodes )
          for i in range(nnodes):
            disp[i] = 0.0

        if var_type != exodus.EX_NODE:

          if var_type == exodus.EX_EDGE: btype = exodus.EX_EDGE_BLOCK
          if var_type == exodus.EX_FACE: btype = exodus.EX_FACE_BLOCK
          if var_type == exodus.EX_ELEM: btype = exodus.EX_ELEM_BLOCK

          # cache the block connectivities
          if not hasattr(self, 'bconn'):
            self.bconn = {}
            self.bconn[exodus.EX_EDGE_BLOCK] = {}
            self.bconn[exodus.EX_FACE_BLOCK] = {}
            self.bconn[exodus.EX_ELEM_BLOCK] = {}
          conn = self.bconn[btype].get(blk_id,None)
          if conn == None:
            conn = self.exoapi.readConn( btype, blk_id, exodus.EX_NODE )
            self.bconn[btype][blk_id] = conn

          blk = self.exoapi.getBlock(btype,blk_id)
          nume = blk[1]
          npe = blk[3]

          c = array.array( self.exoapi.storageType() )
          exodus.resize_array( c, nume )

          if self.displx != None:
            i = 0
            for e in range(nume):
              x = 0.0
              for n in range(npe):
                x = x + disp[ conn[i] ]
                i = i + 1
              c[e] = float( x / npe )
          else:
            for e in range(nume):
              c[e] = 0.0

          return c

        return disp

    #########################################################################

    def _assert(self, boolean):
        if not boolean:
          raise IOError, "Database file corrupt?"

    def _readFile(self, filename):

        xt = ''
        if opts.has_key('--his'):
          return self._readHISPLT(filename)
        elif opts.has_key('--histoa'):
          xt = ".his"
          fp = os.popen( 'histoa ' + filename )
        elif opts.has_key('--exodus'):
          return self._readExodus(filename)
        elif opts.has_key('--txt'):
          return self._readTabular(filename)
        else:
          xt = os.path.splitext(filename)[1]
          if xt == ".his" or xt[:5] == ".his_" or xt == ".base_his" or \
             os.path.basename(filename)[:3] == "hct":
            return self._readHISPLT(filename)
          elif xt == ".exo" or xt == ".base_exo" or xt == ".e" or xt == '.h':
            # *.h files are SIERRA history files (which are Exodus)
            return self._readExodus(filename)
          elif xt in [".txt",".prn"]:
            return self._readTabular(filename)
          elif xt == ".csv":
            return self._readCSV(filename)
          else:
            fp = open(filename, "r")

        got_counts = 0
        got_var_names = 0
        have_cycle = 0
        have_time = 0
        have_dt = 0
        have_cpu = 0
        num_dumps = 0

        line = fp.readline()
        while line:

          line = string.strip(line)

          # try to catch errors generated by the histoa program
          if line[:18] == '*** histoa: error:':
            try: fp.close()
            except: pass
            msg = string.join( string.split( line[19:] ) )

            if msg[:19] == 'unknown record code':
              raise IOError, 'histoa encountered an unknown record code ' + \
                '(note that histoa must be run on the same platform that ' + \
                'the .his file was generated)'
            raise IOError, "histoa returned: " + line[19:]

          if line[:9] == "CODE=-100":
            nlines = int(string.split(line)[2])
            for i in range(nlines):
              line = fp.readline()
              if self.title: self.title + '\n'
              self.title = self.title + string.strip(line)

          elif line[:9] == "CODE=-101":
            nlines = int(string.split(line)[2])
            for i in range(nlines):
              line = fp.readline()
              # TODO: do something with QA strings

          elif line[:9] == "CODE=-102":
            L = string.split( fp.readline() )
            self._assert( L[0] == "NUMPOINTS" and len(L) >= 10 )
            num_points = int(L[1])
            num_mats = int(L[3])
            num_point_vars = int(L[5])
            num_mat_vars = int(L[7])
            num_glob_vars = int(L[9])
            got_counts = 1

          elif line[:9] == "CODE=-103":
            if not got_counts:
              raise IOError, "Invalid database: CODE=-103 before CODE=-102"
            for i in range(num_point_vars):
              L = string.split( fp.readline() )
              self._assert( len(L) >= 3 )
              self._assert( L[0] == "POINTVAR" )
              self.vars[POINTVAR].append( L[1] )
              self._assert( L[2] == "UNITS" )
              if len(L) > 3:
                self.vars[POINTVAR_UNITS].append( L[3] )
              else:
                self.vars[POINTVAR_UNITS].append( "" )
            for i in range(num_mat_vars):
              L = string.split( fp.readline() )
              self._assert( len(L) >= 3 )
              self._assert( L[0] == "MATVAR" )
              self.vars[MATVAR].append( L[1] )
              self._assert( L[2] == "UNITS" )
              if len(L) > 3:
                self.vars[MATVAR_UNITS].append( L[3] )
              else:
                self.vars[MATVAR_UNITS].append( "" )
            for i in range(num_glob_vars):
              L = string.split( fp.readline() )
              self._assert( len(L) >= 3 )
              self._assert( L[0] == "GLOBALVAR" )
              self.vars[GLOBVAR].append( L[1] )
              self._assert( L[2] == "UNITS" )
              if len(L) > 3:
                self.vars[GLOBVAR_UNITS].append( L[3] )
              else:
                self.vars[GLOBVAR_UNITS].append( "" )
            for i in range(num_points):
              L = string.split( fp.readline() )
              self._assert( L[0] == "POINTID" )
              self.vars[POINTID].append( ( int(L[1]), int(L[3]) ) )
            for i in range(num_mats):
              L = string.split( fp.readline() )
              self._assert( L[0] == "MATERIALID" )
              self.vars[MATID].append( int(L[1]) )

            for n in self.vars[GLOBVAR]:
              if n == "CYCLE": have_cycle = 1
              if n == "TIME": have_time = 1
              if n == "DT": have_dt = 1
              if n == "CPU": have_cpu = 1

            if not have_cycle:
              self.vars[GLOBVAR].append( "CYCLE" )
              self.vars[GLOBVAR_UNITS].append( "" )
            if not have_time:
              self.vars[GLOBVAR].append( "TIME" )
              self.vars[GLOBVAR_UNITS].append( "S" )
            if not have_dt:
              self.vars[GLOBVAR].append( "DT" )
              self.vars[GLOBVAR_UNITS].append( "S" )
            if not have_cpu:
              self.vars[GLOBVAR].append( "CPU" )
              self.vars[GLOBVAR_UNITS].append( "S" )

            got_var_names = 1

          elif line[:8] == "CODE=100":

            if not got_var_names:
              raise IOError, "Invalid database: data came before CODE=-103"

            L = string.split( fp.readline() )
            self._assert( L[0] == "CYCLE" )
            self._removeRepeats( int(L[1]) )
            cycl = int(L[1])

            L = string.split( fp.readline() )
            self._assert( L[0] == "TIME" )
            tim = float(L[1])

            L = string.split( fp.readline() )
            self._assert( L[0] == "TIMESTEP" )
            dt = float(L[1])

            L = string.split( fp.readline() )
            self._assert( L[0] == "CPUTIME" )
            cpu = float(L[1])

            pvals = []
            for i in range(num_points):
              L = string.split( fp.readline() )
              self._assert( L[0] == "POINTS" )
              self._assert( len(L[1:]) == num_point_vars )
              fL = []
              for j in range(num_point_vars):
                fL.append( float( L[j+1] ) )
              pvals.append( fL )

            mvals = []
            for i in range(num_mats):
              L = string.split( fp.readline() )
              self._assert( L[0] == "MATERIALS" )
              self._assert( len(L[1:]) == num_mat_vars )
              fL = []
              for j in range(num_mat_vars):
                fL.append( float( L[j+1] ) )
              mvals.append( fL )

            L = string.split( fp.readline() )
            self._assert( len(L) > 1 and L[0] == "GLOBALS" )
            self._assert( len(L[1:]) == num_glob_vars )
            gvals = []
            for j in range(num_glob_vars):
              gvals.append( float( L[j+1] ) )
            if not have_cycle: gvals.append( cycl )
            if not have_time: gvals.append( tim )
            if not have_dt: gvals.append( dt )
            if not have_cpu: gvals.append( cpu )

            if num_dumps == 0 or self.skipval == None or \
                self.skipval <= 0 or num_dumps%self.skipval == 0:
              self.cycles.append( cycl )
              self.times.append( tim )
              self.timesteps.append( dt )
              self.cputimes.append( cpu )
              self.point_values.append( pvals )
              self.mat_values.append( mvals )
              self.glob_values.append( gvals )

            num_dumps = num_dumps + 1

          line = fp.readline()

        if xt == ".his" or xt[:5] == ".his_":
          exit_stat = fp.close()
          if exit_stat != None and int(exit_stat) != 0:
            return "the histoa program failed .. is it in your path?"
        else:
          fp.close()

        return ""

    HISPLT_title_length = 80
    HISPLT_QA_length = 38
    HISPLT_valid_codes = [ -100, -101, -102, -103 ]

    def _readHISPLT(self, filename):
        """
        """
        import hisread

        hd = hisread.HistoryData( filename, self.skipval )
        self.title = hd.title
        self.filename = filename
        self.vars = hd.vars
        self.cycles = hd.cycles
        self.times = hd.times
        self.timesteps = hd.timesteps
        self.cputimes = hd.cputimes
        self.point_values = hd.point_values
        self.mat_values = hd.mat_values
        self.glob_values = hd.glob_values

        return ""

    def _readExodus(self, filename):
        """
        The NetCDF ncdump program is used to extract the time steps, global
        variable names and global variable values.
        """
        self.exoapi = None
        if haveexodus:
          try:
            self.exoapi = exodus.ExodusFile(filename)
            self.geom = 1  # true
          except:
            pass

        if self.exoapi != None:
          # use the python to exodus wrapper to access the exodus API
          tvals = self.exoapi.getTimes()
          for n in self.exoapi.varNames(exodus.EX_GLOBAL):
            self.vars[GLOBVAR].append( n )
            self.vars[GLOBVAR_UNITS].append( "" )
          vals = array.array(self.exoapi.storageType())
          for ti in range(len(tvals)):
            if ti == 0 or self.skipval == None or \
                self.skipval <= 0 or ti%self.skipval == 0:
              self.times.append( tvals[ti] )
              self.exoapi.readVar( ti+1, exodus.EX_GLOBAL, 0, 0, vals )
              self.glob_values.append( vals.tolist() )
          return ""

        # first read the header to find out if there are global variables
        # and time steps

        time_whole = 0
        name_glo_var = 0
        vals_glo_var = 0
        num_names = 0

        fp = os.popen( 'ncdump -h ' + filename )

        variables = 0
        line = fp.readline()
        while line:
          if variables:
            L = string.split(line)
            if len(L) > 1 and L[1][:10] == "time_whole":
              time_whole = 1
            elif len(L) > 1 and L[1][:12] == "name_glo_var":
              name_glo_var = 1
            elif len(L) > 1 and L[1][:12] == "vals_glo_var":
              vals_glo_var = 1
          elif string.strip(line) == "variables:":
            variables = 1
          line = fp.readline()
        exit_stat = fp.close()
        if exit_stat != None and int(exit_stat) != 0:
          return "the ncdump program failed .. is it in your path?"

        if not time_whole or not name_glo_var or not vals_glo_var :
          return ""

        # read the global variable names and time values

        fp = os.popen( 'ncdump -v time_whole,name_glo_var ' + filename )

        data_sect = 0
        time_whole = 0
        name_glo_var = 0
        timeidx = 0

        line = fp.readline()
        while line:
          line = string.strip(line)

          if data_sect and (time_whole or line[:12] == "time_whole ="):
            if time_whole:
              L = string.split( string.join( string.split(line, ',') ) )
            else:
              L = string.split( string.join( string.split(line[12:], ',') ) )
              time_whole = 1
            for v in L:
              if v == ';':
                time_whole = 0
                break
              if timeidx == 0 or self.skipval == None or \
                    self.skipval <= 0 or timeidx%self.skipval == 0:
                self.times.append( float(v) )
              timeidx = timeidx + 1

          elif data_sect and (name_glo_var or line[:14] == "name_glo_var ="):
            if name_glo_var:
              L = string.split(line, '"')
            else:
              L = string.split(line[14:], '"')
              name_glo_var = 1
            if len(L) >= 3:
              # ncdump writes the NULL char as a backslash followed by 000
              n = string.split( L[1], "\\000" )[0]
              self.vars[GLOBVAR].append( n )
              self.vars[GLOBVAR_UNITS].append( "" )
              num_names = num_names + 1
              if L[-1][-1] == ';':
                name_glo_var = 0

          elif line == "data:":
            data_sect = 1

          line = fp.readline()

        exit_stat = fp.close()
        if exit_stat != None and int(exit_stat) != 0:
          return 'executing "ncdump -v name_glo_var ' + filename + '" failed'

        # read the global variable values

        fp = os.popen( 'ncdump -v vals_glo_var ' + filename )

        data_sect = 0
        vals_glo_var = 0
        tlist = []

        timeidx = 0
        line = fp.readline()
        while line:
          line = string.strip(line)

          if data_sect and (vals_glo_var or line[:14] == "vals_glo_var ="):
            if vals_glo_var:
              L = string.split( string.join( string.split(line, ',') ) )
            else:
              L = string.split( string.join( string.split(line[14:], ',') ) )
              vals_glo_var = 1
            for v in L:
              if v == ';':
                vals_glo_var = 0
                break
              tlist.append( float(v) )
              if len(tlist) == num_names:
                if timeidx == 0 or self.skipval == None or \
                    self.skipval <= 0 or timeidx%self.skipval == 0:
                  self.glob_values.append( tlist )
                timeidx = timeidx + 1
                tlist = []

          elif line == "data:":
            data_sect = 1

          line = fp.readline()

        exit_stat = fp.close()
        if exit_stat != None and int(exit_stat) != 0:
          return 'executing "ncdump -v vals_glo_var ' + filename + '" failed'

        if len(tlist) > 0:
          return 'number of global variables != num_names * num steps'

        return ""

    def _readTabular(self, filename):
        """
        Parses a table of the form

          labelA   labelB   labelC   ...
          (unitsA) (unitsB) (unitsC) ...
          <float>  <float>  <float>  ...
          <float>  <float>  <float>  ...
          ...

        where it is assumed time is the first column.  The labels are
        optional, in which case they assume the values "Column1", "Column2",
        etc.  The units line is also optional, in which case empty strings
        are used.  If there are spaces in a label, quotes must surround it.

        Note that the following is also allowed:

          #L labelA   labelB   labelC   ...
          #U (unitsA) (unitsB) (unitsC) ...
          <float>  <float>  <float>  ...
          <float>  <float>  <float>  ...
          ...
        """

        fp = open(filename,"r")

        # skip to first relevant line

        while 1:
          line = fp.readline()
          if not line:
            fp.close()
            return ""
          sline = string.strip(line)
          if sline and ( sline[:3] == '#L ' or sline[0] != '#' ):
            break

        line = string.strip(line)
        if line[:3] == '#L ':
          line = line[3:]

        lineL = string.split(line)
        if len(lineL) < 2:
          fp.close()
          return "first non-empty row only contains one column of data"

        nrows = 0

        # determine if first row is labels

        labels = 0
        try:
          v = float(lineL[0])
        except ValueError:
          labels = 1  # assume label

        if labels:

          L = quoted_tokenize(line)

          ncols = len(L)
          for i in range(ncols-1):
            self.vars[GLOBVAR].append( string.strip(L[i+1]) )

          # check next row for unit labels
          line = fp.readline()
          line = string.strip(line)
          if line[:3] == '#U ':
            line = line[3:]
          lineL = string.split(line)
          if len(lineL) < ncols:
            fp.close()
            return "first row after headings row has too few columns"

          units = 0
          try:
            v = float(lineL[0])
          except ValueError:
            units = 1  # assume units

          if units:
            L = quoted_tokenize(line)
            for s in L[1:]:
              s = string.strip(s)
              if   s[0] == '(' and s[-1] == ')': s = s[1:-1]
              elif s[0] == '[' and s[-1] == ']': s = s[1:-1]
              self.vars[GLOBVAR_UNITS].append( s )
          else:
            for i in range(ncols-1):
              self.vars[GLOBVAR_UNITS].append( "" )
            L = []
            for i in range(ncols):
              try:
                L.append( float(lineL[i]) )
              except:
                break
            if len(L) == ncols:
              self.times.append(L[0])
              self.glob_values.append( L[1:] )
            else:
              fp.close()
              return ""
            nrows = nrows + 1

        else:  # first row is a row of data

          ncols = len(lineL)
          for i in range(ncols-1):
            self.vars[GLOBVAR].append( "Column" + str(i+1) )
            self.vars[GLOBVAR_UNITS].append( "" )
          L = []
          for i in range(ncols):
            try:
              L.append( float(lineL[i]) )
            except:
              break
          if len(L) == ncols:
            self.times.append(L[0])
            self.glob_values.append( L[1:] )
          else:
            fp.close()
            return ""
          nrows = nrows + 1

        while 1:
          line = fp.readline()
          if not line: break
          if not string.strip(line): break
          lineL = string.split(line)
          if len(lineL) < ncols: break
          L = []
          for i in range(ncols):
            try:
              L.append( float(lineL[i]) )
            except:
              break
          if len(L) < ncols:
            break
          if nrows == 0 or self.skipval == None or \
               self.skipval <= 0 or nrows%self.skipval == 0:
            self.times.append(L[0])
            self.glob_values.append( L[1:] )
          nrows = nrows + 1

        fp.close()

        return ""


    def _readCSV(self, filename):
        """
        Parses a table of the form

          "labelA","labelB","labelC"   ...
          "(unitsA)","(unitsB)","(unitsC)" ...
          <float>, <float>, <float>  ...
          <float>, <float>, <float>  ...
          ...

        where it is assumed time is the first column.  The labels are
        optional, in which case they assume the values "Column1", "Column2",
        etc.  The units line is also optional, in which case empty strings
        are used.  If there are spaces in a label, quotes must surround it.
        """

        fp = open(filename,"r")

        # skip to first relevant line

        while 1:
          line = fp.readline()
          if not line:
            fp.close()
            return ""
          sline = string.strip(line)
          if sline and sline[0] != '#': break

        line = string.strip(line)

        lineL = quoted_tokenize(line,',')

        if len(lineL) < 2:
          fp.close()
          return "first non-empty row only contains one column of data"

        nrows = 0

        # determine if first row is labels

        labels = 0
        try:
          v = float(lineL[0])
        except ValueError:
          labels = 1  # assume label

        if labels:

          ncols = len(lineL)
          for i in range(ncols-1):
            self.vars[GLOBVAR].append( string.strip(lineL[i+1]) )

          # check next row for unit labels
          line = fp.readline()
          line = string.strip(line)
          lineL = quoted_tokenize(line,',')
          if len(lineL) < ncols:
            fp.close()
            return "first row after headings row has too few columns"

          units = 0
          try:
            v = float(lineL[0])
          except ValueError:
            units = 1  # assume units

          if units:
            for s in lineL[1:]:
              s = string.strip(s)
              if   s[0] == '(' and s[-1] == ')': s = s[1:-1]
              elif s[0] == '[' and s[-1] == ']': s = s[1:-1]
              self.vars[GLOBVAR_UNITS].append( s )
          else:
            for i in range(ncols-1):
              self.vars[GLOBVAR_UNITS].append( "" )
            L = []
            for i in range(ncols):
              try:
                L.append( float(lineL[i]) )
              except:
                break
            if len(L) == ncols:
              self.times.append(L[0])
              self.glob_values.append( L[1:] )
            else:
              fp.close()
              return ""
            nrows = nrows + 1

        else:  # first row is a row of data

          ncols = len(lineL)
          for i in range(ncols-1):
            self.vars[GLOBVAR].append( "Column" + str(i+1) )
            self.vars[GLOBVAR_UNITS].append( "" )
          L = []
          for i in range(ncols):
            try:
              L.append( float(lineL[i]) )
            except:
              break
          if len(L) == ncols:
            self.times.append(L[0])
            self.glob_values.append( L[1:] )
          else:
            fp.close()
            return ""
          nrows = nrows + 1

        while 1:
          line = fp.readline()
          if not line: break
          if not string.strip(line): break
          lineL = quoted_tokenize(line,',')
          if len(lineL) < ncols: break
          L = []
          for i in range(ncols):
            try:
              L.append( float(lineL[i]) )
            except:
              break
          if len(L) < ncols:
            break
          if nrows == 0 or self.skipval == None or \
               self.skipval <= 0 or nrows%self.skipval == 0:
            self.times.append(L[0])
            self.glob_values.append( L[1:] )
          nrows = nrows + 1

        fp.close()

        return ""

    def _removeRepeats(self, newcycle):
        popcount = 0
        if self.nodups and len(self.cycles) > 0:
          i = -1
          while (-i) <= len(self.cycles) and newcycle <= self.cycles[i]:
            popcount = popcount + 1
            i = i - 1
        if popcount > 0:
          for i in range(popcount):
            self.cycles.pop(-1)
            self.times.pop(-1)
            self.timesteps.pop(-1)
            self.cputimes.pop(-1)
            self.point_values.pop(-1)
            self.mat_values.pop(-1)
            self.glob_values.pop(-1)


############################################################################

def windowPosition( geom_string ):
    """
    Takes a geometry string given by, for example, winfo_geometry() and
    returns the x,y position string which can be given back to a geometry call.
    """
    xpos = ''
    ypos = ''
    for c in geom_string:
      if c == '+' or c == '-':
        if not xpos: xpos = c
        else: ypos = c
      elif ypos:
        ypos = ypos + c
      elif xpos:
        xpos = xpos + c
    if xpos and ypos:
      return xpos + ypos
    return None


class SortList:
    """
    Helper class that takes a list and sorts it but provides the index
    mappings back and forth between the original and sorted lists.
    """

    def __init__(self, origlist):

        self.L = []
        self.sortL = []
        for c in origlist:
          self.L.append( c )
          self.sortL.append( c )
        self.sortL.sort()

        self.Lidx = {}  # maps string to original index
        i = 0
        for s in self.L:
          self.Lidx[s] = i
          i = i + 1

        self.sortLidx = {}  # maps string to sorted index
        i = 0
        for s in self.sortL:
          self.sortLidx[s] = i
          i = i + 1

        self.LtoS = []  # maps original index to sorted index
        for s in self.L:
          self.LtoS.append( self.sortLidx[s] )

        self.StoL = []  # maps sorted index to original index
        for s in self.sortL:
          self.StoL.append( self.Lidx[s] )

    def origList(self): return self.L
    def sortList(self): return self.sortL

    def orig(self, i):
        assert i >= 0 and i < len(self.L)
        return self.L[i]

    def sorted(self, i):
        assert i >= 0 and i < len(self.sortL)
        return self.sortL[i]

    def origIndex(self, name):
        return self.Lidx.get(name, None)

    def sortedIndex(self, name):
        if type(name) == type(0.0):
          for i in range(len(self.sortL)):
            if name < self.sortL[i]:
              if i == 0: return 0
              if name-self.sortL[i-1] < self.sortL[i]-name:
                return i-1
              return i
          return len(self.sortL)-1
        return self.sortLidx.get(name, None)

    def toSortedIndex(self, orig_idx):
        assert orig_idx >= 0 and orig_idx < len(self.LtoS)
        return self.LtoS[orig_idx]

    def toOrigIndex(self, sorted_idx):
        assert sorted_idx >= 0 and sorted_idx < len(self.StoL)
        return self.StoL[sorted_idx]


class ProfileChooser:

    def __init__(self, parent, idstring):

        self.parent = parent
        self.idstring = str(idstring)
        self.toplev = None
        self.toploc = None

        self.refresh_listener = None
        self.var_listener = None
        self.lists = [ None, None, None, None, None ]  # use sorted indexes
        self.vals = [ None, None, None, None, None ]  # use unsorted indexes
        self.sort = [ None, None, None, None, None ]  # SortList objects

        self.tformat = "%.16e"

    def setRefreshListener(self, l):
        self.refresh_listener = l

    def setVarListener(self, l):
        self.var_listener = l

    def setTimeFormat(self, format):
        self.tformat = format

    def setContent(self, var_type, alist):
        """
        Use NODE, EDGE, FACE, ELEM, or TIME.  Sets the variable names for the
        variable type to the given list.
        """
        self.vals[var_type] = []
        for v in alist:
          self.vals[var_type].append( [0,v] )
        self.sort[var_type] = SortList(alist)

    def getActiveIndexes(self, var_type):
        """
        Use NODE, EDGE, FACE, ELEM, or TIME.  Returns a list of the indexes
        that are active for that type.
        """
        idxs = []
        for i in range(len(self.vals[var_type])):
          if self.vals[var_type][i][0]:
            idxs.append(i)
        return idxs

    def activate(self, var_type, name):
        """
        Searches for name and if found, selects it.  Refresh is NOT called.
        """
        if self.sort[var_type] != None:
          sorti = self.sort[var_type].sortedIndex(name)
          if sorti != None:
            if self.toplev != None and self.lists[var_type] != None:
              self.lists[var_type].selection_set( sorti )
            i = self.sort[var_type].toOrigIndex( sorti )
            self.vals[var_type][i][0] = 1

    def activateVariables(self, var_type):
        """
        Activates all variables of the given type, but does not touch the times.
        """
        assert var_type == NODE or var_type == EDGE or \
               var_type == FACE or var_type == ELEM
        if self.sort[var_type] != None:
          for i in range(len(self.sort[var_type].origList())):
            self.vals[var_type][i][0] = 1

    def deactivate(self, var_type, name):
        if self.sort[var_type] != None:
          sorti = self.sort[var_type].sortedIndex(name)
          if sorti != None:
            if self.toplev != None and self.lists[var_type] != None:
              self.lists[var_type].selection_clear( sorti )
            i = self.sort[var_type].toOrigIndex( sorti )
            self.vals[var_type][i][0] = 0

    def visible(self):
        if self.toplev != None and self.toplev.state() == "normal":
          return 1
        return 0

    def hide(self):
        if self.toplev != None and self.toplev.state() == "normal":
          self.toplev.iconify()

    def destroy(self, event):
        if self.toplev != None:
          if hasattr( self.toplev, "winfo_geometry" ):
            self.toploc = windowPosition( self.toplev.winfo_geometry() )
          self.toplev.unbind( '<Destroy>' )
          self.toplev.destroy()
          self.toplev = None

    def show(self):
        if self.toplev != None:
          self.toplev.deiconify()
          self.toplev.tkraise()
          self.toplev.focus_set()
        else:
          self.toplev = Toplevel( self.parent )
          if self.toploc != None:
            self.toplev.geometry( self.toploc )
          try: self.toplev.wm_title( self.idstring )
          except: pass
          self.toplev.bind( '<Destroy>', self.destroy )
          self._createSkeleton()
          for var_type in [ NODE, EDGE, FACE, ELEM, TIME ]:
            if self.vals[var_type] != None:
              maxlen = 0
              sorti = 0
              for v in self.sort[var_type].sortList():
                s = str(v)
                if var_type == TIME: s = (self.tformat)%v
                i = self.sort[var_type].toOrigIndex(sorti)
                onoff = self.vals[var_type][i][0]
                self._addItem( var_type, onoff, s )
                if maxlen < len(s): maxlen = len(s)
                sorti = sorti + 1
              if var_type == TIME: maxlen = maxlen + 1
              else:                maxlen = maxlen + 4
              if var_type == MATID and maxlen < 6: maxlen = 6
              self.lists[var_type].configure( width=maxlen )

    def _createSkeleton(self):
        self._createFrame( NODE, "Node" )
        self._createFrame( EDGE, "Edge" )
        self._createFrame( FACE, "Face" )
        self._createFrame( ELEM, "Element" )
        self._createFrame( TIME, "Time" )

    def click(self, list_idx):

        assert list_idx >= 0 and list_idx < 5

        valsL = self.vals[list_idx]

        curlen = 0
        for pr in valsL:
          if pr[0]:
            curlen = curlen + 1

        varchange = []
        if self.var_listener != None:
          assert self.lists[list_idx].size() == len(valsL)
          for sorti in range(self.lists[list_idx].size()):
            list_val = int( self.lists[list_idx].selection_includes(sorti) )
            i = self.sort[list_idx].toOrigIndex(sorti)
            pr = valsL[i]
            if list_val != pr[0]:
              varchange.append( ( pr[1], list_val ) )

        for pr in valsL:
          pr[0] = 0
        for sorti in self.lists[list_idx].curselection():
          i = self.sort[list_idx].toOrigIndex( int(sorti) )
          valsL[i][0] = 1

        for ( var_name, list_val ) in varchange:
          self.var_listener.varSelect( list_idx, var_name, list_val )

        newlen = 0
        for pr in valsL:
          if pr[0]:
            newlen = newlen + 1

        if self.refresh_listener != None:
          if curlen == 0 or newlen == 0:
            self.refresh_listener.resetData(auto_zoom.get())
          else:
            self.refresh_listener.refreshVars(auto_zoom.get())

    def _createFrame(self, idx, label):
        frm = Frame( self.toplev, borderwidth=2, relief=GROOVE )
        frm.pack( side=LEFT, fill=Y )
        Label( frm, text=label ).pack( side=TOP )
        lst = Listbox( frm, borderwidth=2, relief=GROOVE,
                       exportselection=0, selectmode=EXTENDED )
        self.lists[idx] = lst
        scroll = Scrollbar( frm, command=lst.yview )
        lst.configure( yscrollcommand=scroll.set )
        lst.pack( side=LEFT, fill=Y )
        scroll.pack( side=RIGHT, fill=Y )
        lst.bind( '<ButtonRelease>', lambda event, dc=self, i=idx: dc.click(i) )

    def _addItem(self, var_type, onoff, labelstr ):
        self.lists[var_type].insert( END, labelstr )
        if onoff: self.lists[var_type].selection_set( END )


class HistoryChooser:

    def __init__(self, parent, idstring):

        self.parent = parent
        self.idstring = str(idstring)
        self.toplev = None
        self.toploc = None

        self.refresh_listener = None
        self.var_listener = None
        self.lists = [ None, None, None, None, None ]  # use sorted indexes
        self.vals = [ None, None, None, None, None ]  # use unsorted indexes
        self.sort = [ None, None, None, None, None ]  # SortList objects

    def setRefreshListener(self, l):
        self.refresh_listener = l

    def setVarListener(self, l):
        self.var_listener = l

    def setContent(self, var_type, alist):
        """
        Use POINTID, POINTVAR, MATID, MATVAR, or GLOBVAR.  Sets the values
        for the variable type to the given list.
        """
        self.vals[var_type] = []
        for v in alist:
          self.vals[var_type].append( [0,v] )
        self.sort[var_type] = SortList(alist)

    def getActiveIndexes(self, var_type):
        """
        Use POINTID, POINTVAR, MATID, MATVAR, or GLOBVAR.  Returns a list of
        the indexes that are active for that type.
        """
        idxs = []
        for i in range(len(self.vals[var_type])):
          if self.vals[var_type][i][0]:
            idxs.append(i)
        return idxs

    def getIndex(self, var_type, name):
        """
        Searches for name in the current list of values.  Returns index or
        -1 if not found.
        """
        if self.sort[var_type] != None:
          sorti = self.sort[var_type].sortedIndex(name)
          if sorti != None:
            return self.sort[var_type].toOrigIndex( sorti )
        return -1

    def activate(self, var_type, name):
        """
        Searches for name and if found, selects it.  Refresh is NOT called.
        """
        if self.sort[var_type] != None:
          sorti = self.sort[var_type].sortedIndex(name)
          if sorti != None:
            if self.toplev != None and self.lists[var_type] != None:
              self.lists[var_type].selection_set( sorti )
            i = self.sort[var_type].toOrigIndex( sorti )
            self.vals[var_type][i][0] = 1

    def activateVariables(self):
        """
        Activates all variables and ids.
        """
        for var_type in [ POINTID, POINTVAR, MATID, MATVAR, GLOBVAR]:
          if self.sort[var_type] != None:
            for i in range(len(self.sort[var_type].origList())):
              self.vals[var_type][i][0] = 1

    def deactivate(self, var_type, name):
        if self.sort[var_type] != None:
          sorti = self.sort[var_type].sortedIndex(name)
          if sorti != None:
            if self.toplev != None and self.lists[var_type] != None:
              self.lists[var_type].selection_clear( sorti )
            i = self.sort[var_type].toOrigIndex( sorti )
            self.vals[var_type][i][0] = 0

    def visible(self):
        if self.toplev != None and self.toplev.state() == "normal":
          return 1
        return 0

    def hide(self):
        if self.toplev != None and self.toplev.state() == "normal":
          self.toplev.iconify()

    def destroy(self, event):
        if self.toplev != None:
          if hasattr( self.toplev, "winfo_geometry" ):
            self.toploc = windowPosition( self.toplev.winfo_geometry() )
          self.toplev.unbind( '<Destroy>' )
          self.toplev.destroy()
          self.toplev = None

    def show(self):
        if self.toplev != None:
          self.toplev.deiconify()
          self.toplev.tkraise()
          self.toplev.focus_set()
        else:
          self.toplev = Toplevel( self.parent )
          if self.toploc != None:
            self.toplev.geometry( self.toploc )
          self.toplev.wm_title( self.idstring )
          try: self.toplev.wm_title( self.idstring )
          except: pass
          self.toplev.bind( '<Destroy>', self.destroy )
          self._createSkeleton()
          for var_type in [ POINTID, POINTVAR, MATID, MATVAR, GLOBVAR ]:
            if self.vals[var_type] != None:
              maxlen = 0
              sorti = 0
              for v in self.sort[var_type].sortList():
                s = str(v)
                i = self.sort[var_type].toOrigIndex(sorti)
                onoff = self.vals[var_type][i][0]
                self._addItem( var_type, onoff, s )
                if maxlen < len(s): maxlen = len(s)
                sorti = sorti + 1
              maxlen = maxlen + 4
              if var_type == MATID and maxlen < 6: maxlen = 6
              self.lists[var_type].configure( width=maxlen )

    def _createSkeleton(self):
        self._createFrame( POINTID,  "Point ID" )
        self._createFrame( POINTVAR, "Point Variable" )
        self._createFrame( MATID,    "Material ID" )
        self._createFrame( MATVAR,   "Material Variable" )
        self._createFrame( GLOBVAR,  "Global Variable" )

    def click(self, list_idx):

        assert list_idx >= 0 and list_idx < 5

        curlen = 0
        for pr in self.vals[list_idx]:
          if pr[0]:
            curlen = curlen + 1

        varchange = []
        if self.var_listener != None:
          assert self.lists[list_idx].size() == len(self.vals[list_idx])
          for sorti in range(self.lists[list_idx].size()):
            list_val = int( self.lists[list_idx].selection_includes(sorti) )
            i = self.sort[list_idx].toOrigIndex(sorti)
            pr = self.vals[list_idx][i]
            if list_val != pr[0]:
              varchange.append( ( pr[1], list_val ) )

        for pr in self.vals[list_idx]:
          pr[0] = 0
        for sorti in self.lists[list_idx].curselection():
          i = self.sort[list_idx].toOrigIndex( int(sorti) )
          self.vals[list_idx][i][0] = 1

        for ( var_name, list_val ) in varchange:
          self.var_listener.varSelect( list_idx, var_name, list_val )

        newlen = 0
        for pr in self.vals[list_idx]:
          if pr[0]:
            newlen = newlen + 1

        if self.refresh_listener != None:
          if curlen == 0 or newlen == 0:
            self.refresh_listener.resetData(auto_zoom.get())
          else:
            self.refresh_listener.refreshVars(auto_zoom.get())

    def _createFrame(self, idx, label):
        frm = Frame( self.toplev, borderwidth=2, relief=GROOVE )
        frm.pack( side=LEFT, fill=Y )
        Label( frm, text=label ).pack( side=TOP )
        self.lists[idx] = Listbox( frm, borderwidth=2, relief=GROOVE,
                                   exportselection=0, selectmode=EXTENDED )
        scroll = Scrollbar( frm, command=self.lists[idx].yview )
        self.lists[idx].configure( yscrollcommand=scroll.set )
        self.lists[idx].pack( side=LEFT, fill=Y )
        scroll.pack( side=RIGHT, fill=Y )
        self.lists[idx].bind( '<ButtonRelease>',
                              lambda event, dc=self, i=idx: dc.click(i) )

    def _addItem(self, var_type, onoff, labelstr ):
        self.lists[var_type].insert( END, labelstr )
        if onoff: self.lists[var_type].selection_set( END )


############################################################################

class LineSpec:

    def __init__(self, file_string=''):
        self.file_string = file_string
        self.x_var = [ '','','' ]  # name, type, id
        self.y_var = [ '','','' ]  # name, type, id
        self.xlabel = ""
        self.ylabel = ""
        self.xunits = ""
        self.yunits = ""

    def setXvar(self, vname, vtype, vid):
        self.x_var = [ vname, vtype, vid ]

    def setYvar(self, vname, vtype, vid):
        self.y_var = [ vname, vtype, vid ]

    def sameVar(self, line_spec2):
        return self.x_var[0] == line_spec2.x_var[0] and \
               self.x_var[1] == line_spec2.x_var[1] and \
               self.y_var[0] == line_spec2.y_var[0] and \
               self.y_var[1] == line_spec2.y_var[1]

    def key(self):
        return self.file_string + str(self.x_var) + str(self.y_var)

    def __str__(self):
        return "LineSpec(" + self.file_string   + "," + \
                             str(self.x_var[0]) + "," + \
                             str(self.x_var[1]) + "," + \
                             str(self.x_var[2]) + "," + \
                             str(self.y_var[0]) + "," + \
                             str(self.y_var[1]) + "," + \
                             str(self.y_var[2]) + "," + \
                             self.xlabel + "," + \
                             self.ylabel + ')'

    def __cmp__(self, other):
        if other == None:
          return 1
        if self.file_string == other.file_string:
          if self.x_var == other.x_var:
            if self.y_var == other.y_var:
              return 0
            if self.y_var < other.y_var:
              return -1
            return 1
          if self.x_var < other.x_var:
            return -1
          return 1
        if self.file_string < other.file_string:
          return -1
        return 1


class ProfileSelector:

    def __init__(self, file_data, shivcanv, listener):

        self.file_data = file_data

        dc = ProfileChooser( shivcanv, file_data.identifier() )
        dc.setRefreshListener(listener)
        for t in [ NODE, EDGE, FACE, ELEM ]:
          dc.setContent( t, file_data.getVarNames(t) )

        # try to determine a good number of significant digits to show;  if
        # anything goes wrong, just do 16 digits
        tvals = file_data.getTimeValues()
        if len(tvals) < 2:
          self.tformat = "%.3e"
        else:
          ndig = 2
          while ndig < 16:
            enough = 1
            fmt = "%." + str(ndig) + "e"
            s1 = ''
            for t in tvals:
              s2 = fmt % t
              if s1 == s2:
                enough = 0
                break
              s1 = s2
            if enough:
              break
            ndig = ndig + 1
          ndig = ndig + 1
          self.tformat = "%." + str(ndig) + "e"
	dc.setTimeFormat(self.tformat)
        dc.setContent( TIME, file_data.getTimeValues() )
        dc.setVarListener(self)
        self.data_chooser = dc

        self.xaxisvar = None
        self.prev = None
        self.next = None

        # node list has entries (x val, y val, node idx) while edge, face, elem
        # have entries (x val, y val, block id, elem idx)
        self.xN, self.xG, self.xF, self.xE = file_data.getXlines()

    def resetLinks(self, prev):
        self.prev = prev
        if prev != None:
          prev.next = self
        self.next = None

    def delete(self):
        self.prev = None
        self.next = None
        if self.data_chooser != None:
          self.data_chooser.destroy(None)  # cause the window to close
        self.file_data = None
        self.data_chooser = None

    def showXAxisChooser(self, parent, listener):
        if self.xaxisvar == None:
          fd = self.file_data
          self.xaxisvar = ProfileChooser( parent, "X-Axis Variable" )
          self.xaxisvar.setRefreshListener(listener)
          for t in [ NODE, EDGE, FACE, ELEM ]:
            self.xaxisvar.setContent( t, fd.getVarNames(t) )
        self.xaxisvar.show()

    def varSelect(self, var_type, var_name, turnon ):
        """
        Called by the ProfileChooser when a variable is clicked on/off.  This
        object was registered as a listener in the constructor.
        The turnon argument is true if the variable name is to be turned on.
        """
        if self.prev == None:
          hs = self.next
          while hs != None:
            if turnon: hs.data_chooser.activate( var_type, var_name )
            else:      hs.data_chooser.deactivate( var_type, var_name )
            hs = hs.next

    def getXVars(self):
        """
        """
        xvars = []

        if self.xaxisvar != None:

          # collect the variable types, ids, and names of variables

          # TODO: need to query the xaxisvar for node/edge/face/element
          #       variables

          pass

        return xvars

    def collectData(self, collector, preexisting):

        # only the first file in the linked list can have an X-Axis chooser
        # and we need to get the active selections, if any
        xvars = []
        first_file = self
        while first_file.prev != None:
          first_file = first_file.prev
        xvars = first_file.getXVars()

        fd = self.file_data
        dc = self.data_chooser

        timeL = fd.getTimeValues()

        def block_vals( bL, xl, ti, bt, vi ):
            """
            Local scope function to collect the xvalues and values for a
            block variable across all blocks.
            """
            valL = {}
            displ = {}
            for b in bL:
              valL[b] = fd.getGeomValues( ti, bt, vi, b )
              displ[b] = fd.getDispl( ti, bt, b )

            xvals = []
            vals = []
            for x,y,bid,e in xl:
              xvals.append( x + displ[bid][e] )
              vals.append( valL[bid][e] )

            return xvals, vals

        for typ,xL in [ (ELEM, self.xE), (FACE, self.xF), (EDGE, self.xG) ]:

          for xline in xL:

            D = {}
            for x,y,bid,e in xline:
              D[bid] = None
            bidL = D.keys()

            for vidx in dc.getActiveIndexes(typ):

              varname = fd.getVarNames(typ)[vidx]

              for timei in dc.getActiveIndexes(TIME):

                ls = LineSpec( fd.identifier() )
                ls.xlabel = "X"
                ls.setYvar( varname, typ, timei )
                ls.ylabel = varname + ' @ ' + (self.tformat)%(timeL[timei])

                if preexisting.has_key(ls.key()):
                  collector.append( [ls, None, None] )

                else:
                  xvals, vals = block_vals( bidL, xline, timei, typ, vidx )
                  assert len(xvals) == len(vals)
                  collector.append( [ls, xvals, vals] )

        for xline in self.xN:

          for vidx in dc.getActiveIndexes(NODE):

            varname = fd.getVarNames(NODE)[vidx]

            for timei in dc.getActiveIndexes(TIME):

              ls = LineSpec( fd.identifier() )
              ls.xlabel = "X"
              ls.setYvar( varname, NODE, timei )
              ls.ylabel = varname + ' @ ' + (self.tformat)%(timeL[timei])

              if preexisting.has_key(ls.key()):
                collector.append( [ls, None, None] )

              else:

                displ = fd.getDispl( timei, NODE, 0 )
                valL = fd.getGeomValues( timei, NODE, vidx, 0 )

                xL = []
                vals = []
                for x,y,n in xline:
                  xL.append( x + displ[n] )
                  vals.append( valL[n] )

                collector.append( [ls, xL, vals] )


class HistorySelector:

    def __init__(self, file_data, shivcanv, listener):

        self.file_data = file_data

        dc = HistoryChooser( shivcanv, file_data.identifier() )
        dc.setRefreshListener(listener)
        for t in [ POINTID, POINTVAR, MATID, MATVAR, GLOBVAR ]:
          dc.setContent( t, file_data.getList(t) )
        dc.setVarListener(self)
        self.data_chooser = dc

        self.xaxisvar = None
        self.prev = None
        self.next = None

    def resetLinks(self, prev):
        self.prev = prev
        if prev != None:
          prev.next = self
        self.next = None

    def delete(self):
        self.prev = None
        self.next = None
        if self.data_chooser != None:
          self.data_chooser.destroy(None)  # cause the window to close
        self.file_data = None
        self.data_chooser = None

    def showXAxisChooser(self, parent, listener):
        if self.xaxisvar == None:
          fd = self.file_data
          self.xaxisvar = HistoryChooser( parent, "X-Axis Variable" )
          self.xaxisvar.setRefreshListener(listener)
          for t in [ POINTID, POINTVAR, MATID, MATVAR, GLOBVAR ]:
            self.xaxisvar.setContent( t, fd.getList(t) )
        self.xaxisvar.show()

    def varSelect(self, var_type, var_name, turnon ):
        """
        Called by the HistoryChooser when a variable is clicked on/off.  This
        object was registered as a listener in the constructor.
        The turnon argument is true if the variable name is to be turned on.
        """
        if self.prev == None:
          hs = self.next
          while hs != None:
            if turnon: hs.data_chooser.activate( var_type, var_name )
            else:      hs.data_chooser.deactivate( var_type, var_name )
            hs = hs.next

    def getXVars(self):

        xvars = []

        if self.xaxisvar != None:

          # collect the variable types, ids, and names of variables

          fd = self.file_data
          dc = self.data_chooser
          L1 = self.xaxisvar.getActiveIndexes(POINTVAR)
          L2 = self.xaxisvar.getActiveIndexes(POINTID)
          if len(L1) > 0 and len(L2) > 0:
            for i in L1:
              vname = fd.getList(POINTVAR)[i]
              units = fd.getUnitsList(POINTVAR)[i]
              for j in L2:
                vid = fd.getList(POINTID)[j]
                ls = LineSpec()
                ls.xlabel = vname + ", ID " + str(vid[0])
                ls.x_var = [ vname, POINTVAR, vid ]
                ls.xunits = units
                xvars.append(ls)
          L1 = self.xaxisvar.getActiveIndexes(MATVAR)
          L2 = self.xaxisvar.getActiveIndexes(MATID)
          if len(L1) > 0 and len(L2) > 0:
            for i in L1:
              vname = fd.getList(MATVAR)[i]
              units = fd.getUnitsList(MATVAR)[i]
              for j in L2:
                vid = fd.getList(MATID)[j]
                ls = LineSpec()
                ls.xlabel = vname + ", ID " + str(vid)
                ls.x_var = [ vname, MATVAR, vid ]
                ls.xunits = units
                xvars.append(ls)
          L1 = self.xaxisvar.getActiveIndexes(GLOBVAR)
          if len(L1) > 0:
            for i in L1:
              vname = fd.getList(GLOBVAR)[i]
              units = fd.getUnitsList(GLOBVAR)[i]
              ls = LineSpec()
              ls.xlabel = vname
              ls.setXvar(vname, GLOBVAR, 0)
              ls.xunits = units
              xvars.append(ls)

        return xvars

    def collectData(self, collector, preexisting ):

        # only the first file in the linked list can have an X-Axis chooser
        # and we need to get the active selections, if any
        xvars = []
        first_file = self
        while first_file.prev != None:
          first_file = first_file.prev
        xvars = first_file.getXVars()

        self._collect( xvars, POINTVAR, POINTID, collector, preexisting )
        self._collect( xvars, MATVAR, MATID, collector, preexisting )
        self._collect( xvars, GLOBVAR, None, collector, preexisting )

    def _collect(self, xvars, var_type, id_type, collector, preexisting ):

        fd = self.file_data
        dc = self.data_chooser

        xvalsL = []
        if len(xvars) == 0:
          ls = LineSpec()
          ls.xlabel = "Time"
          ls.xunits = "S"
          xvalsL = [ (fd.getTimeValues(),ls) ]
        else:
          for ls in xvars:
            if ls.x_var[1] == POINTVAR:
              vidx = dc.getIndex(POINTVAR, ls.x_var[0])
              pidx = dc.getIndex(POINTID, ls.x_var[2])
              if vidx >= 0 and pidx >= 0:
                xvalsL.append( (fd.getValues(POINTVAR, vidx, pidx),ls) )
            elif ls.x_var[1] == MATVAR:
              vidx = dc.getIndex(MATVAR, ls.x_var[0])
              midx = dc.getIndex(MATID, ls.x_var[2])
              if vidx >= 0 and midx >= 0:
                xvalsL.append( (fd.getValues(MATVAR, vidx, midx),ls) )
            else:
              assert ls.x_var[1] == GLOBVAR
              idx = dc.getIndex(GLOBVAR, ls.x_var[0])
              if idx >= 0:
                xvalsL.append( (fd.getValues(GLOBVAR, idx),ls) )

        for (xvals,xls) in xvalsL:
          for vidx in dc.getActiveIndexes(var_type):
            varname = fd.getList(var_type)[vidx]
            unitsname = fd.getUnitsList(var_type)[vidx]
            if id_type != None:
              for pidx in dc.getActiveIndexes(id_type):
                vals = fd.getValues( var_type, vidx, pidx )
                varid = fd.getList(id_type)[pidx]
                ls = LineSpec(fd.identifier())
                ls.setXvar( xls.x_var[0], xls.x_var[1], xls.x_var[2] )
                ls.xlabel = xls.xlabel
                ls.xunits = xls.xunits
                ls.setYvar(varname, var_type, varid)
                if id_type == POINTID:
                  ls.ylabel = varname + ", ID " + str(varid[0])
                else:
                  ls.ylabel = varname + ", ID " + str(varid)
                if string.strip(unitsname):
                  ls.yunits = string.strip(unitsname)
                  ls.ylabel = ls.ylabel + " [" + ls.yunits + "]"
                else:
                  ls.yunits = ""
                if preexisting.has_key(ls.key()):
                  collector.append( [ls, None, None] )
                else:
                  assert len(xvals) == len(vals)
                  collector.append( [ls, xvals, vals] )
            else:
              vals = fd.getValues( var_type, vidx )
              ls = LineSpec(fd.identifier())
              ls.setXvar( xls.x_var[0], xls.x_var[1], xls.x_var[2] )
              ls.xlabel = xls.xlabel
              ls.xunits = xls.xunits
              ls.setYvar(varname, var_type, 0)
              if string.strip(unitsname):
                ls.yunits = string.strip(unitsname)
                ls.ylabel = varname + " [" + ls.yunits + "]"
              else:
                ls.ylabel = varname
                ls.yunits = ""
              if preexisting.has_key(ls.key()):
                collector.append( [ls, None, None] )
              else:
                assert len(xvals) == len(vals)
                collector.append( [ls, xvals, vals] )


###############################################################################

def sameLimits( wbox, b ):
    """
    Expects wbox and b to be lists [ xmin,xmax, ymin,ymax ].  This function
    decides whether the y values of the two boxes are close enough to use
    the same limits.  If so, the ymin,ymax values of wbox are modified to
    encompass the y limts of b.  True is returned if they are close enough,
    else false.
    """
    h1 = wbox[3]-wbox[2]
    h2 = b[3]-b[2]
    if h1 == h2 or (h1 < h2 and h1 > h2/2.0) or \
                   (h1 > h2 and h2 > h1/2.0):
      h = h1
      if h1 > h2: h = h2
      h = h/3.0
      if b[2] > wbox[2] - h and b[2] < wbox[2] + h:
        if wbox[2] > b[2]: wbox[2] = b[2]
        if wbox[3] < b[3]: wbox[3] = b[3]
        return 1
    return 0


###############################################################################

class DataManager:

    def __init__(self, shiv_canvas):
        self.shivcanv = shiv_canvas
        self.hisL = []  # list of HistorySelector objects
        self.profL = []  # list of ProfileSelector objects
        self.activeL = self.hisL
        self.view = DATAVIEW_HISTORY
        self.logx = 0
        self.logy = 0
        self.scale = 0
        self.first_zoom = 1
        self.first_var = 1

        self.dlines = []  # list of (LineSpec,DataLine) pairs

        if self.shivcanv != None: self.ltypes = LineTypePool()

    def setLogY(self, logy):
        self.logy = logy
        if self.shivcanv != None: self.shivcanv.setLogY( logy )

    def setLogX(self, logx):
        self.logx = logx
        if self.shivcanv != None: self.shivcanv.setLogX( logx )

    def setScale(self, scale):
        self.scale = scale
        if self.shivcanv != None: self.shivcanv.setScale( scale )

    def showXAxisChooser(self):
        if len(self.activeL) > 0:
          self.activeL[0].showXAxisChooser(self.shivcanv, self)

    def showChooser(self, idstring):
        item = None
        for hs in self.activeL:
          if idstring == hs.file_data.identifier():
            hs.data_chooser.show()
            break

    def switchView(self, view):
        assert view == DATAVIEW_HISTORY or view == DATAVIEW_PROFILE or \
               view == DATAVIEW_POINTS
        if view == DATAVIEW_HISTORY:
          if self.view == DATAVIEW_PROFILE:
            if len(self.hisL) == 0:
              return 0
            for ps in self.profL:
              if ps.data_chooser.visible():
                fdid = ps.file_data.identifier()
                for hs in self.hisL:
                  if fdid == hs.file_data.identifier():
                    hs.data_chooser.show()
                ps.data_chooser.hide()
          self.view = view
          self.activeL = self.hisL
        elif view == DATAVIEW_PROFILE:
          if self.view == DATAVIEW_HISTORY:
            if len(self.profL) == 0:
              return 0
            for hs in self.hisL:
              if hs.data_chooser.visible():
                fdid = hs.file_data.identifier()
                for ps in self.profL:
                  if fdid == ps.file_data.identifier():
                    ps.data_chooser.show()
                hs.data_chooser.hide()
          self.view = view
          self.activeL = self.profL
        else:
          return 0
        self.resetData()
        return 1

    def addFileData(self, file_data):

        if opts.has_key('-L'):
          bname = file_data.filename
        else:
          bname = os.path.basename(file_data.filename)
        cnt = 0
        for hs in self.hisL + self.profL:
          if opts.has_key('-L'):
            if hs.file_data.filename == bname:
              if cnt < hs.cnt:
                cnt = hs.cnt
          else:
            if os.path.basename(hs.file_data.filename) == bname:
              if cnt < hs.cnt:
                cnt = hs.cnt
        if cnt == 0:
          # basename was not found
          cnt = 1
          idstring = bname
        else:
          # at least one file of the same basename
          cnt = cnt + 1
          idstring = bname + '-' + str(cnt)

        file_data.setIdentifier(idstring)

        if file_data.hasGeometry():
          hs = ProfileSelector(file_data, self.shivcanv, self)
          hs.cnt = cnt
          if len(self.profL) > 0:
            hs.resetLinks( self.profL[-1] )
          self.profL.append(hs)

        hs = HistorySelector(file_data, self.shivcanv, self)
        hs.cnt = cnt
        if len(self.hisL) > 0:
          hs.resetLinks( self.hisL[-1] )
        self.hisL.append(hs)

        if self.shivcanv != None:
          self.shivcanv.setTitle( file_data.title )
          self.refreshVars()

        return idstring

    def removeFileData(self, fname_id):

        prev = None
        newhis = []
        for hs in self.hisL:
          if hs.file_data.identifier() == fname_id:
            hs.delete()
          else:
            hs.resetLinks(prev)
            prev = hs
            if len(newhis) == 0:
              hs.data_chooser.setRefreshListener(self)
            newhis.append(hs)
            self.shivcanv.setTitle( hs.file_data.title )
        self.hisL = newhis
        prev = None
        newprof = []
        for hs in self.profL:
          if hs.file_data.identifier() == fname_id:
            hs.delete()
          else:
            hs.resetLinks(prev)
            prev = hs
            if len(newprof) == 0:
              hs.data_chooser.setRefreshListener(self)
            newprof.append(hs)
            self.shivcanv.setTitle( hs.file_data.title )
        self.profL = newprof
        if self.view == DATAVIEW_HISTORY:
          self.activeL = self.hisL
        else:
          self.activeL = self.profL
        self.refreshVars()

    def printToFile(self, filename, landscape, fmt):
        return self.shivcanv.printToFile(filename,landscape,fmt)

    def batchSelect(self, var_type, var_name ):
        """
        Meant to be called only during batch invocation of shiv, the
        var_type can any of POINTID, POINTVAR, MATID, MATVAR, or GLOBVAR.

        """
        if self.view == DATAVIEW_PROFILE:
          for hs in self.profL:
            dc = hs.data_chooser
            if var_type == INDEX:
              tL = self.profL[0].file_data.getTimeValues()
              if len(tL) > 0:
                if var_name < 0 or var_name >= len(tL):
                  dc.activate( var_type, tL[-1] )
                else:
                  dc.activate( var_type, tL[var_name] )
            elif var_type == CYCLE:
              tL = self.profL[0].file_data.getTimeValues()
              cL = self.profL[0].file_data.getCycles()
              if len(tL) > 0:
                if var_name < 0:
                  dc.activate( TIME, tL[-1] )
                elif len(tL) == len(cL):  # in case cycle list not available
                  for i in range(len(cL)):
                    if var_name == cL[i]:
                      dc.activate( TIME, tL[i] )
                      break
            else:
              dc.activate( var_type, var_name )

        else:
          for hs in self.activeL:
            dc = hs.data_chooser
            if var_type == POINTID:
              dc.activate( POINTID, ( var_name, 0 ) )
              dc.activate( POINTID, ( var_name, 1 ) )
              dc.activate( POINTID, ( var_name, 2 ) )
            else:
              dc.activate( var_type, var_name )

    def batchSelectAll(self, var_type=None):
        """
        Meant to be called only during batch invocation of shiv, it selects
        all variables and ids for export.  The var_type is required when the
        view is in spatial profile mode.
        """
        if self.view == DATAVIEW_PROFILE:
          assert var_type != None
          assert var_type == NODE or var_type == EDGE or \
                 var_type == FACE or var_type == ELEM
          for ps in self.profL:
            ps.data_chooser.activateVariables(var_type)
        else:
          for hs in self.activeL:
            hs.data_chooser.activateVariables()

    def computeBoundingBox(self):
        """
        Uses self.dlines to create a bounding zoom box.
        Returns [ xmin,xmax, ymin,ymax, ymin2,ymax2 ].
        """
        same_limits = 1

        if len(self.dlines) == 0:
          wbox = [ 0.0, 1.0, 0.0, 1.0, 0.0, 1.0 ]

        else:

          wboxL = None
          for (ls,dline) in self.dlines:
            b = dline.getBox()
            if dline.axis == "left":
              if wboxL == None:
                wboxL = [ b[0], b[1], b[2], b[3] ]
              else:
                if b[0] < wboxL[0]: wboxL[0] = b[0]
                if b[1] > wboxL[1]: wboxL[1] = b[1]
                if b[2] < wboxL[2]: wboxL[2] = b[2]
                if b[3] > wboxL[3]: wboxL[3] = b[3]

          wboxR = None
          for (ls,dline) in self.dlines:
            b = dline.getBox()
            if dline.axis != "left":
              if wboxR == None:
                wboxR = [ b[0], b[1], b[2], b[3] ]
              else:
                if b[0] < wboxR[0]: wboxR[0] = b[0]
                if b[1] > wboxR[1]: wboxR[1] = b[1]
                if b[2] < wboxR[2]: wboxR[2] = b[2]
                if b[3] > wboxR[3]: wboxR[3] = b[3]

          wbox = [ wboxL[0], wboxL[1], wboxL[2], wboxL[3], wboxL[2], wboxL[3] ]
          if wboxR != None:
            # always want the X axis limits to encompass both data sets
            if wbox[0] > wboxR[0]: wbox[0] = wboxR[0]
            if wbox[1] < wboxR[1]: wbox[1] = wboxR[1]
            # see if the L and R axis limits are "close enough" to be the same
            same_limits = sameLimits( wbox, wboxR )

          wbox[0], wbox[1] = adjustRange( wbox[0], wbox[1] )
          wbox[2], wbox[3] = adjustRange( wbox[2], wbox[3] )

          wbox[4] = wbox[2] ; wbox[5] = wbox[3]
          if not same_limits:
            wbox[4], wbox[5] = adjustRange( wboxR[2], wboxR[3] )

        return wbox, same_limits

    def refreshVars(self, reset_zoom=0, old_order=None):
        """
        Checks for new variables to be shown and old variables to be removed.
        If old_order is not None, it should be a list of LineSpec instances
        that give an order for the variables.
        """
        preexisting = {}
        for (ls,dline) in self.dlines:
          preexisting[ ls.key() ] = None

        collector = []
        for hs in self.activeL:
          hs.collectData( collector, preexisting )

        if old_order != None:
          # reorder the variables according to the old_order list
          new_collector = []
          for old_ls in old_order:
            i = 0
            for (ls,xvals,vals) in collector:
              if ls != None and old_ls == ls:
                new_collector.append( [ls, xvals, vals] )
                collector[i] = [ None, None, None ]
                break
              i = i + 1
          # pick up any in collector that are not in the old order list
          for (ls,xvals,vals) in collector:
            if ls != None:
              new_collector.append( [ ls, xvals, vals ] )
          collector = new_collector

        allkeys = {}
        for (ls,xvals,yvals) in collector:
          allkeys[ ls.key() ] = ls

        # remove any DataLine objects that are no longer active
        newL = []
        for (ls,dline) in self.dlines:
          lskey = ls.key()
          if not allkeys.has_key(lskey):
            self.ltypes.release( lskey )
            self.shivcanv.removeDataLine( dline )
          else:
            newL.append( (ls,dline) )
        self.dlines = newL

        xlab = None
        newDLs = []
        for (ls,xvals,yvals) in collector:
          if xlab == None: xlab = ls.xlabel
          elif ls.xlabel != xlab: xlab = ""
          if xvals != None:
            # create a new DataLine object
            plotdata = applyDataMods( xvals, yvals, \
                                      self.logx, self.logy, self.scale )
            assert len(plotdata) > 0
            lt = self.ltypes.choose( ls.key() )
            # add the line object to the canvas
            line = DataLine( self.shivcanv.xform, plotdata, lt, ls.ylabel )
            self.dlines.append( (ls,line) )
            self.shivcanv.addDataLine( line )
            newDLs.append( line )

        for (ls,dl) in self.dlines:
          assert xlab != None
          if xlab: varlabel = ls.ylabel
          else:    varlabel = ls.xlabel + " VS. " + ls.ylabel
          if len(self.activeL) > 1:
            varlabel = "(" + ls.file_string + ") " + varlabel
          dl.label = varlabel

        if self.shivcanv != None:
          self.shivcanv.setXLabel(xlab)

        # set the axis and Transformer for each line
        if self.shivcanv != None and rhs_axis.get():

          # create a dictionary mapping variable keys to bounding boxes
          boxD = {}
          for (ls,dl) in self.dlines:
            vkey = ( ls.x_var[0], ls.x_var[1], ls.y_var[0], ls.y_var[1] )
            b = dl.getBox()
            if boxD.has_key(vkey):
              b2 = boxD[vkey]
              b[2] = min( b[2], b2[2] )
              b[3] = max( b[3], b2[3] )
              boxD[vkey] = ( b[0], b[1], b[2], b[3] )
            else:
              boxD[ vkey ] = b

          # place each of the variables on the left or right
          bL = None
          bR = None
          nameD = {}
          for (ls,dl) in self.dlines:

            vkey = ( ls.x_var[0], ls.x_var[1], ls.y_var[0], ls.y_var[1] )

            if bL == None:
              bL = dl.getBox()
              dl.xform = self.shivcanv.xform
              dl.axis = "left"
              nameD[vkey] = "left"
            else:
              side = nameD.get(vkey,None)
              if side == None:
                # name not already in left or right list
                b = dl.getBox()
                if sameLimits( b, bL ):
                  # close enough to left limits
                  dl.xform = self.shivcanv.xform
                  dl.axis = "left"
                  nameD[vkey] = "left"
                elif bR == None:
                  # first right axis limits
                  bR = b
                  dl.xform = self.shivcanv.xform2
                  dl.axis = "right"
                  nameD[vkey] = "right"
                elif sameLimits( b, bR ):
                  # close enough to right limits
                  dl.xform = self.shivcanv.xform2
                  dl.axis = "right"
                  nameD[vkey] = "right"
                else:
                  # not close to either limits, so force onto left side
                  dl.xform = self.shivcanv.xform
                  dl.axis = "left"
                  nameD[vkey] = "left"
              elif side == "left":
                # name already in left list
                dl.xform = self.shivcanv.xform
                dl.axis = "left"
              else:
                # name already in right list
                assert side == "right"
                dl.xform = self.shivcanv.xform2
                dl.axis = "right"

        else:
          for (ls,dl) in self.dlines:
            dl.axis = "left"
            dl.xform = self.shivcanv.xform

        if self.first_var and len(self.dlines) > 0:
          reset_zoom = 1
          self.first_var = 0

        if self.shivcanv != None:
          if self.first_zoom or reset_zoom:
            wbox, same_limits = self.computeBoundingBox()
            L,R,B,T     = self.shivcanv.xform.world
            L2,R2,B2,T2 = self.shivcanv.xform2.world
            self.shivcanv.zoomL.append( (L,R,B,T,L2,R2,B2,T2) )
            self.shivcanv.xform.setWorld( wbox[0], wbox[1], wbox[2], wbox[3] )
            self.shivcanv.xform2.setWorld( wbox[0], wbox[1], wbox[4], wbox[5] )
            self.shivcanv.xform2.same_limits = same_limits
            self.first_zoom = 0
            self.shivcanv.draw()
          else:
            for dl in newDLs:
              self.shivcanv.draw(dl)

    def refreshZoom(self):
        """
        Resets the zoom window to show all the data of all current variables.
        """
        wbox, same_limits = self.computeBoundingBox()
        L,R,B,T     = self.shivcanv.xform.world
        L2,R2,B2,T2 = self.shivcanv.xform2.world
        self.shivcanv.zoomL.append( (L,R,B,T,L2,R2,B2,T2) )
        self.shivcanv.xform.setWorld( wbox[0], wbox[1], wbox[2], wbox[3] )
        self.shivcanv.xform2.setWorld( wbox[0], wbox[1], wbox[4], wbox[5] )
        self.shivcanv.xform2.same_limits = same_limits
        self.shivcanv.draw()
        self.first_zoom = 0

    def zoomBack(self):
        """
        """
        if len(self.shivcanv.zoomL) > 0:
          L,R,B,T,L2,R2,B2,T2 = self.shivcanv.zoomL.pop()
          self.shivcanv.xform.setWorld( L,R,B,T )
          self.shivcanv.xform2.setWorld( L2,R2,B2,T2 )
          self.shivcanv.draw()

    def rereadData(self):
        """
        Refreshes the data to the latest values in the files.
        """
        self.shivcanv.rhsaxis.clear()
        oldL = []
        for (ls,dline) in self.dlines:
          oldL.append( ls )
          self.shivcanv.removeDataLine( dline )
        self.dlines = []
        for hs in self.activeL:
          fd = hs.file_data
          fd.reread()
        self.refreshVars( reset_zoom=auto_zoom.get(), old_order=oldL )

    def resetData(self, reset_zoom=1):
        """
        Refreshes the data and applies log manipulation, if needed.
        """
        if self.shivcanv != None:
          self.shivcanv.rhsaxis.clear()
        oldL = []
        for (ls,dline) in self.dlines:
          oldL.append( ls )
          if self.shivcanv != None:
            self.shivcanv.removeDataLine( dline )
        self.dlines = []
        self.refreshVars( reset_zoom=reset_zoom, old_order=oldL )

    def clearData(self):
        self.shivcanv.clear()
        for hs in self.hisL:
          hs.delete()
        self.hisL = []
        for hs in self.profL:
          hs.delete()
        self.profL = []
        if self.view == DATAVIEW_HISTORY:
          self.activeL = self.hisL
        else:
          self.activeL = self.profL

    def export(self, fileobj, format):
        """
        The known formats are "xmgr", "tab", and "csvtab".
        """
        collector = []
        for hs in self.activeL:
          hs.collectData( collector, {} )
          if format != "xmgr":
            break  # the tabular forms do not support multiple files

        if len(collector) == 0:
          return

        xlab = None
        xunits = None
        xlen = None
        newL = []
        uniq = {}
        for (ls,xvals,yvals) in collector:
          add = 0
          if uniq.has_key(ls.key()):
            pass
          elif xlab == None:
            xlab = ls.xlabel
            xunits = ls.xunits
            add = 1
          elif format == "xmgr":
            if ls.xlabel != xlab:
              xlab = ""
              xunits = ""
            add = 1
          elif ls.xlabel == xlab:
            add = 1
          if add and xlen == None:
            xlen = len(xvals)
          if add and len(xvals) == xlen:
            uniq[ls.key()] = None
            plotdata = applyDataMods( xvals, yvals, \
                                      self.logx, self.logy, self.scale )
            newL.append( ["",ls,plotdata] )

        for i in range(len(newL)):
          L = newL[i]
          ls = L[1]
          if xlab: varlabel = ls.ylabel
          else:    varlabel = ls.xlabel + " VS. " + ls.ylabel
          if format == "xmgr" and len(self.activeL) > 1:
            varlabel = "(" + ls.file_string + ") " + varlabel
          L[0] = varlabel

        if format == "xmgr":
          fileobj.write( '@ with g0\n' )
          fileobj.write( '@ legend on\n' )
          fileobj.write( '@ legend loctype view\n' )
          fileobj.write( '@ legend char size 0.75\n' )
          plotnum = 0
          for (varlabel,ls,plotdata) in newL:
            fileobj.write( '@ title "' + varlabel + '"\n' )
            fileobj.write( '@ subtitle "' + ls.xlabel + ' vs ' + \
                                            ls.ylabel + '"\n' )
            fileobj.write( '@ xaxis label "' + ls.xlabel + '"\n' )
            fileobj.write( '@ yaxis label "' + ls.ylabel + '"\n' )
            fileobj.write( '@ legend string ' + str(plotnum) + ' "' + \
                                               ls.ylabel + '"\n' )
            fileobj.write( '@ s' + str(plotnum) + ' comment "' + \
                                                       ls.ylabel + '"\n' )
            for (t,v) in plotdata:
              fileobj.write( "%.16e %.16e\n" % (t,v) )
            fileobj.write( '&\n' )
            plotnum = plotnum + 1

        else:

          # text or csv table format

          tab = []
          if len(newL) > 0:
            numrows = len( newL[0][2] )
            if numrows > 0:
              for (t,v) in newL[0][2]:
                s = "%.16e" % t
                if s[0] != '-': s = ' ' + s
                tab.append( [ s ] )
              for (varlabel,ls,plotdata) in newL:
                for i in range( len(plotdata) ):
                  s = "%.16e" % (plotdata[i][1])
                  if s[0] != '-': s = ' ' + s
                  tab[i].append( s )

          if xlab == None:
            xlab = ''
            xunits = ''
          if xunits and xlab[-len(xunits)-2:] == '[' + xunits + ']':
            xlab = string.strip( xlab[:-len(xunits)-2] )
          if ' ' in xlab:
            xlab = '"' + xlab + '"'
          if ' ' in xunits:
            xunits = '"[' + xunits + ']"'
          else:
            xunits = '[' + xunits + ']'

          cols = []
          colu = []
          have_units = 0
          for (varlabel,ls,plotdata) in newL:
            units = string.strip(ls.yunits)
            if units:
              have_units = 1
            if units and varlabel[-len(units)-2:] == '[' + units + ']':
              varlabel = string.strip( varlabel[:-len(units)-2] )
            if ' ' in varlabel:
              varlabel = '"' + varlabel + '"'
            if ' ' in units:
              units = '"[' + units + ']"'
            else:
              units = '[' + units + ']'
            cols.append( varlabel )
            colu.append( units )

          if format == "tab":

            if not opts.has_key('--nolabels'):
              fileobj.write( "#L %-21s" % xlab )
              for lab in cols:
                fileobj.write( " %-23s" % lab )
              fileobj.write( "\n" )
              if have_units:
                fileobj.write( "#U %-21s" % xunits )
                for lab in colu:
                  fileobj.write( " %-23s" % lab )
                fileobj.write( "\n" )
            for row in tab:
              fileobj.write( string.join(row) + "\n" )

          else:
            assert format == "csvtab"
            if not opts.has_key('--nolabels'):
              L = [xlab]
              for lab in cols: L.append(lab)
              fileobj.write( string.join(L,',') + '\n' )
              if have_units:
                L = [xunits]
                for lab in colu: L.append(lab)
                fileobj.write( string.join(L,',') + '\n' )
            for row in tab:
              first = 1
              for v in row:
                if first: fileobj.write( v )
                else:     fileobj.write( ',' + v )
                first = 0
              fileobj.write( "\n" )

        return ""


############################################################################

def applyDataMods( xvals, yvals, logx, logy, scale ):
    """
    """
    # TODO: work out how to avoid making copies of the data arrays -- instead,
    #       just manipulate the existing array (which may get shorter)

    # TODO: change the way logs are done: actually apply the log here instead;
    #       will have to change the transformer in order to recover the
    #       correct hoverval

    assert len(xvals) > 0 and len(xvals) == len(yvals)

    plotdata = []

    if not logx and not logy:
      for i in range(len(xvals)):
        plotdata.append( (xvals[i],yvals[i]) )

    elif logx and not logy:
      for i in range(len(xvals)):
        if xvals[i] > 0.0:
          plotdata.append( (xvals[i],yvals[i]) )
      if len(plotdata) == 0:
        for i in range(len(xvals)):
          if xvals[i] < 0.0:
            plotdata.append( (-xvals[i],yvals[i]) )
      if len(plotdata) == 0:
        for i in range(len(xvals)):
          if xvals[i] > 0.0:
            plotdata.append( (xvals[i],yvals[i]) )

    elif not logx and logy:
      for i in range(len(xvals)):
        if yvals[i] > 0.0:
          plotdata.append( (xvals[i],yvals[i]) )
      if len(plotdata) == 0:
        for i in range(len(xvals)):
          if yvals[i] < 0.0:
            plotdata.append( (xvals[i],-yvals[i]) )
      if len(plotdata) == 0:
        for i in range(len(xvals)):
          if xvals[i] > 0.0:
            plotdata.append( (xvals[i],yvals[i]) )

    else:
      for i in range(len(xvals)):
        if xvals[i] > 0.0 and yvals[i] > 0.0:
          plotdata.append( (xvals[i],yvals[i]) )
      if len(plotdata) == 0:
        for i in range(len(xvals)):
          if xvals[i] < 0.0 and yvals[i] < 0.0:
            plotdata.append( (-xvals[i],-yvals[i]) )
      if len(plotdata) == 0:
        for i in range(len(xvals)):
          if xvals[i] > 0.0 and yvals[i] < 0.0:
            plotdata.append( (xvals[i],-yvals[i]) )
      if len(plotdata) == 0:
        for i in range(len(xvals)):
          if xvals[i] < 0.0 and yvals[i] > 0.0:
            plotdata.append( (-xvals[i],yvals[i]) )
      if len(plotdata) == 0:
        for i in range(len(xvals)):
          plotdata.append( (xvals[i],yvals[i]) )

    assert len(plotdata) > 0

    if scale:
      ymin = plotdata[0][1];  ymax = ymin
      for i in range(len(plotdata)):
        y = plotdata[i][1]
        if y < ymin: ymin = y
        if y > ymax: ymax = y
      diff = float(ymax - ymin)
      if diff < SMALL_FLOAT:
        ymin = float( (ymin+ymax)/2.0 )
        for i in range(len(plotdata)):
          x = plotdata[i][0];  y = plotdata[i][1]
          plotdata[i] = ( x, y-ymin+0.5 )
      else:
        for i in range(len(plotdata)):
          x = plotdata[i][0];  y = plotdata[i][1]
          plotdata[i] = ( x, (y-ymin)/diff )

    return plotdata

############################################################################

def fileLoad( args, dman, bar ):

  # for the .his* file extension, group according to directory
  fD = {}
  fL = []
  for f in args:
    b,x = os.path.splitext(f)
    if x == ".his" or x[:5] == ".his_":
      fb = b + ".his"
      if fD.has_key(fb):
        fD[fb].append(f)
      else:
        L = [ f ]
        fD[fb] = L
        fL.append(L)
    else:
      fL.append( [f] )

  for L in fL:
    try:
      # this simple sort handles .his_* up to 9; things will get jumbled
      # for greater than 9, such as .his_10 and .his_11
      L.sort()
      fd = FileData( L[0], opts.get('--skip',None) )
      L.pop(0)
      for f in L:
        fd.mergeFile(f)
      ids = dman.addFileData( fd )
      if bar != None:
        bar.addFileButton( ids,
                     lambda event, dm=dman, fn=ids: dm.showChooser(fn) )
    except IOError, e:
      print "*** shiv: could not read file:", str(e)
      sys.exit(1)


############################################################################

if __name__ == "__main__":

  for a in sys.argv[1:]:
    if a == '--install':

      args = []
      prefix = '/usr/local'
      for a in sys.argv[1:]:
        if a[:9] == "--prefix=":
          prefix = string.split(a, "=", 1)[1]
        elif a[:1] == "-":
          pass
        else:
          args.append(a)

      instinc = os.path.normpath( os.path.join( prefix, 'include' ) )
      instlib = os.path.normpath( os.path.join( prefix, 'lib' ) )
      instbin = os.path.normpath( os.path.join( prefix, 'bin' ) )

      tcldir = tkdir = pythondir = None
      if len(args) > 0:
        if len(args) != 3:
          print "*** shiv: error: exactly zero or 3 arguments must be given"
          sys.exit(1)
        for a in args:
          if a[:3] == 'tcl':  tcldir = a
          elif a[:2] == 'tk': tkdir = a
          else:               pythondir = a
      else:
        for f in os.listdir( os.getcwd() ):
          if f[:3] == 'tcl' and os.path.isdir(f): tcldir = f
          elif f[:2] == 'tk' and os.path.isdir(f): tkdir = f
          elif f[:6] == 'Python' and os.path.isdir(f): pythondir = f

      if tcldir == None or tkdir == None or pythondir == None:
        print "*** shiv: error: could not determine tcl, tk, and python " + \
              "package directories; please list them as arguments"
        sys.exit(1)

      mname = os.uname()[0]
      if mname == "Linux":
        os.environ['CC'] = 'gcc'
        os.environ['CXX'] = 'g++'
      elif mname == "SunOS":
        os.environ['CC'] = 'cc'
        os.environ['CXX'] = 'CC'
      elif mname == "IRIX64":
        os.environ['CC'] = 'cc'
        os.environ['CXX'] = 'CC'
      elif mname == "AIX":
        os.environ['CC'] = 'cc'
        os.environ['CXX'] = 'xlC'
      elif mname == "OSF1":
        os.environ['CC'] = 'cc'
        os.environ['CXX'] = 'cxx'

      for f in os.listdir( os.getcwd() ):
        if f[:8] == 'readline':
          cmd = 'cd ' + f + ' ; make distclean' ; print cmd
          os.system(cmd)
          cmd = 'cd ' + f + ' ; ./configure --prefix=' + prefix ; print cmd
          if os.system(cmd) != 0: sys.exit(1)
          cmd = 'cd ' + f + ' ; make' ; print cmd
          if os.system(cmd) != 0: sys.exit(1)
          cmd = 'cd ' + f + ' ; make install' ; print cmd
          if os.system(cmd) != 0: sys.exit(1)
          break

      cmd = 'cd ' + tcldir + '/unix ; make distclean' ; print cmd
      os.system(cmd)
      cmd = 'cd ' + tcldir + '/unix ; ./configure --prefix=' + prefix ; print cmd
      if os.system(cmd) != 0: sys.exit(1)
      cmd = 'cd ' + tcldir + '/unix ; make' ; print cmd
      if os.system(cmd) != 0: sys.exit(1)
      cmd = 'cd ' + tcldir + '/unix ; make install' ; print cmd
      if os.system(cmd) != 0: sys.exit(1)

      cmd = 'cd ' + tkdir + '/unix ; make distclean' ; print cmd
      os.system(cmd)
      cmd = 'cd ' + tkdir + '/unix ; ./configure --prefix=' + prefix; print cmd
      if os.system(cmd) != 0: sys.exit(1)
      cmd = 'cd ' + tkdir + '/unix ; make' ; print cmd
      if os.system(cmd) != 0: sys.exit(1)
      cmd = 'cd ' + tkdir + '/unix ; make install' ; print cmd
      if os.system(cmd) != 0: sys.exit(1)

      #if os.environ.has_key('LD_LIBRARY_PATH'):
      #  os.environ['LD_LIBRARY_PATH'] = instlib + ':' + \
      #                                  os.environ['LD_LIBRARY_PATH']
      #else:
      #  os.environ['LD_LIBRARY_PATH'] = instlib

      # Notes: I found LINKFORSHARED in the configure script.
      #        The following stuff can be removed but LD_LIBRARY_PATH may
      #        need to have the install lib path added during build and at
      #        runtime.

      xtra = ''
      if mname == "Linux":
        if instlib != '/usr/lib' and instlib != '/usr/local/lib':
          # -rpath builds the tcl/tk shared lib path into the python executable
          os.environ['LINKFORSHARED'] = '-Xlinker -export-dynamic ' + \
                                        '-Xlinker -rpath -Xlinker ' + instlib
      elif mname == "SunOS":
        if instlib != '/usr/lib':
          os.environ['CC'] = 'cc -R ' + instlib
          os.environ['CXX'] = 'CC -R ' + instlib
      elif mname == "IRIX64":
        if instlib != '/usr/lib' and instlib != '/usr/local/lib':
          # -rpath builds the tcl/tk shared lib path into the python executable
          os.environ['LINKFORSHARED'] = '-rpath ' + instlib
      elif mname == 'AIX':
        xtra = ' --disable-ipv6'
      elif mname == "OSF1":
        if instlib != '/usr/lib' and instlib != '/usr/local/lib':
          # -rpath builds the tcl/tk shared lib path into the python executable
          os.environ['LINKFORSHARED'] = '-rpath ' + instlib

      cmd = 'cd ' + pythondir + ' ; make distclean' ; print cmd
      os.system(cmd)
      cmd = 'cd ' + pythondir + ' ; ./configure --prefix=' + prefix + xtra
      print cmd
      if os.system(cmd) != 0: sys.exit(1)
      cmd = 'cd ' + pythondir + ' ; make' ; print cmd
      if os.system(cmd) != 0: sys.exit(1)
      cmd = 'cd ' + pythondir + ' ; make install' ; print cmd
      if os.system(cmd) != 0: sys.exit(1)

      print " "
      print "shiv: python has been installed in " + instbin
      print "      If python fails to import Tkinter, you may need to add"
      print "          " + instlib
      print "      to your LD_LIBRARY_PATH environment variable."
      print " "

      sys.exit(0)



try:
  opts, args = getopt.getopt( sys.argv[1:], "hVbp:m:g:t:i:c:e:d:f:n:L",
                  longopts=[ 'help', 'version',
                             'his', 'histoa', 'txt', 'exodus', 'skip=',
                             'batch', 'point=', 'matrial=', 'global=',
                             'time=', 'output-index=', 'cycle-index=',
                             'element=', 'edge=', 'face=', 'node=',
                             'xelements', 'xedges', 'xfaces', 'xnodes',
                             'csv', 'tab', 'xmgr', 'nolabels', 'yzclip=' ] )
except getopt.error, e:
  sys.stderr.write('*** shiv: error: ' + str(e) + '\n' )
  sys.exit(1)

D = {}
for op in opts:
  if   op[0] == '--batch':        n = '-b'
  elif op[0] == '--point':        n = '-p'
  elif op[0] == '--material':     n = '-m'
  elif op[0] == '--global':       n = '-g'
  elif op[0] == '--time':         n = '-t'
  elif op[0] == '--output-index': n = '-i'
  elif op[0] == '--cycle-index':  n = '-c'
  elif op[0] == '--element':      n = '-e'
  elif op[0] == '--edge':         n = '-d'
  elif op[0] == '--face':         n = '-f'
  elif op[0] == '--node':         n = '-n'
  else:                           n = op[0]
  L = D.get(n,[])
  L.append(op[1])
  D[n] = L
opts = D

if opts.has_key('--help') or opts.has_key('-h'):
  print manpage
  sys.exit(0)

if opts.has_key('-V') or opts.has_key('--version'):
  print version
  sys.exit(0)

if opts.has_key('--skip'):
  try: v = int( opts['--skip'][-1] )
  except ValueError, e:
    print "shiv: error: --skip argument must be a positive integer"
    sys.exit(1)
  if v < 0:
    print "shiv: error: --skip argument must be a positive integer"
    sys.exit(1)
  opts['--skip'] = v

if opts.has_key('--yzclip'):
  L = string.split( opts['--yzclip'][-1], '/' )
  for s in L:
    try: v = float( L[0] )
    except ValueError, e:
      print "shiv: error: unable to parse --yzclip argument:", L[0]
      sys.exit(1)
  if len(L) == 1:
    yzclip = [ float(L[0]), None, None, None ]
  elif len(L) == 2:
    yzclip = [ float(L[0]), float(L[1]), None, None ]
  elif len(L) == 3:
    yzclip = [ float(L[0]), float(L[1]), float(L[2]), None ]
  elif len(L) >= 4:
    yzclip = [ float(L[0]), float(L[1]), float(L[2]), float(L[3]) ]

if ( opts.has_key('-p') or opts.has_key('-m') or opts.has_key('-g') ) and \
   ( opts.has_key('-t') or opts.has_key('-i') or opts.has_key('-c') ):
  print "shiv: error: cannot mix batch history export options with " + \
                     "spatial export options"
  sys.exit(1)

if ( opts.has_key('-p') or opts.has_key('-m') or opts.has_key('-g') ) and \
   ( opts.has_key('-e') or opts.has_key('-d') or opts.has_key('-f') or \
     opts.has_key('-n') or opts.has_key('--xelements') or \
     opts.has_key('--xelements') or opts.has_key('--xedges') or \
     opts.has_key('--xfaces') or opts.has_key('--xnodes') ):
  print "shiv: error: cannot mix batch history export options with " + \
                     "spatial export options"
  sys.exit(1)

if ( opts.has_key('-e') and opts.has_key('-d') ) or \
   ( opts.has_key('-e') and opts.has_key('-f') ) or \
   ( opts.has_key('-e') and opts.has_key('-n') ) or \
   ( opts.has_key('-d') and opts.has_key('-f') ) or \
   ( opts.has_key('-d') and opts.has_key('-n') ) or \
   ( opts.has_key('-f') and opts.has_key('-n') ):
  print "shiv: error: cannot mix spatial export options -edfn " + \
                     "(use one at a time, but it may be repeated)"
  sys.exit(1)

if ( opts.has_key('--xelements') and opts.has_key('--xedges') ) or \
   ( opts.has_key('--xelements') and opts.has_key('--xfaces') ) or \
   ( opts.has_key('--xelements') and opts.has_key('--xnodes') ) or \
   ( opts.has_key('--xedges') and opts.has_key('--xfaces') ) or \
   ( opts.has_key('--xedges') and opts.has_key('--xnodes') ) or \
   ( opts.has_key('--xfaces') and opts.has_key('--xnodes') ):
  print "shiv: error: cannot mix spatial export options --xelements, " + \
        "--xedges, --xfaces and --xnodes (only one may appear)"
  sys.exit(1)

if opts.has_key('-b'):

  # batch mode

  # if a spatial field is specified but no time plane, select last time plane
  if ( opts.has_key('-e') or opts.has_key('-d') or opts.has_key('-f') or \
       opts.has_key('-n') or opts.has_key('--xelements') or \
       opts.has_key('--xedges') or opts.has_key('--xfaces') or \
       opts.has_key('--xnodes') ) and not \
     ( opts.has_key('-t') or opts.has_key('-i') or opts.has_key('-c') ):
    opts['-c'] = [-1]

  # if no history or field variables are specified and a time plane is
  # not specified, then default to dumping all history variables
  all_his = 0
  if not ( opts.has_key('-p') or opts.has_key('-m') or opts.has_key('-g') or \
           opts.has_key('-t') or opts.has_key('-i') or opts.has_key('-c') ):
    all_his = 1

  if len(args) > 0:

    #import exodus
    try:
      import exodus
      import array
      haveexodus = 1
    except Exception, e:
      haveexodus = 0

    dataman = DataManager(None)

    fileLoad( args, dataman, None )

    if all_his or opts.has_key('-p') or opts.has_key('-m') or \
                  opts.has_key('-g'):

      # history variables

      if all_his:

        dataman.batchSelectAll()

      else:

        for v in opts.get('-p',[]):
          L = string.split( string.strip(v), '/', 1 )
          if len(L) != 2:
            print "*** shiv: error: could not parse command line " + \
                  "point variable:", v
            sys.exit(1)
          try: i = int(L[0])
          except:
            print "*** shiv: error: could not parse command line " + \
                  "point variable:", v
            sys.exit(1)
          dataman.batchSelect( POINTID, int(L[0]) )
          dataman.batchSelect( POINTVAR, L[1] )

        for v in opts.get('-m',[]):
          L = string.split( string.strip(v), '/', 1 )
          if len(L) != 2:
            print "*** shiv: error: could not parse command line " + \
                  "material variable:", v
            sys.exit(1)
          try: i = int(L[0])
          except:
            print "*** shiv: error: could not parse command line " + \
                  "material variable:", v
            sys.exit(1)
          dataman.batchSelect( MATID, int(L[0]) )
          dataman.batchSelect( MATVAR, L[1] )

        for v in opts.get('-g',[]):
          dataman.batchSelect( GLOBVAR, v )

    elif opts.has_key('-t') or opts.has_key('-i') or opts.has_key('-c'):

      # geometry variables

      if dataman.switchView( DATAVIEW_PROFILE ):

        if opts.has_key('-t'):
          for v in opts['-t']:
            try: t = float(v)
            except:
              print "*** shiv: error: could not parse command line " + \
                  "time value:", v
              sys.exit(1)
            dataman.batchSelect( TIME, t )
        elif opts.has_key('-i'):
          for v in opts['-i']:
            try: i = int(v)
            except:
              print "*** shiv: error: could not parse command line " + \
                  "time plane index value:", v
              sys.exit(1)
            dataman.batchSelect( INDEX, i )
        else:
          assert opts.has_key('-c')
          for v in opts['-c']:
            try: c = int(v)
            except:
              print "*** shiv: error: could not parse command line " + \
                  "time cycle index value:", v
              sys.exit(1)
            dataman.batchSelect( CYCLE, c )

        # if no spatial field was selected, choose all node variables
        if not ( opts.has_key('-e') or opts.has_key('-d') or \
                 opts.has_key('-f') or opts.has_key('-n') or \
                 opts.has_key('--xelements') or opts.has_key('--xedges') or \
                 opts.has_key('--xfaces') or opts.has_key('--xnodes') ):
          opts['--xnodes'] = None

        if opts.has_key('--xelements'):
          dataman.batchSelectAll(ELEM)
        elif opts.has_key('--xedges'):
          dataman.batchSelectAll(EDGE)
        elif opts.has_key('--xfaces'):
          dataman.batchSelectAll(FACE)
        elif opts.has_key('--xnodes'):
          dataman.batchSelectAll(NODE)
        else:
          for v in opts.get('-e',[]):
            dataman.batchSelect( ELEM, v )
          for v in opts.get('-d',[]):
            dataman.batchSelect( EDGE, v )
          for v in opts.get('-f',[]):
            dataman.batchSelect( FACE, v )
          for v in opts.get('-n',[]):
            dataman.batchSelect( NODE, v )

    xformat = "tab"
    if   opts.has_key('--csv'):  xformat = "csvtab"
    elif opts.has_key('--xmgr'): xformat = "xmgr"

    dataman.export( sys.stdout, xformat )

  sys.exit(0)


############################################################################

#import exodus
try:
  import exodus
  import array
  haveexodus = 1
except Exception, e:
  haveexodus = 0


try:
  from Tkinter import *
except Exception, e:
  print e
  print "*** shiv: error: could not import Tkinter; run shiv -h and " + \
        "read the REQUIREMENTS section"
  sys.exit(1)

try:
  from tkFileDialog import *
except:
  pass

try:
  import tkSimpleDialog
except:
  pass


try:
  from tkMessageBox import *
except:
  pass


try:
  import tkFont
  default_font = tkFont.Font()
except:
  tkFont = None
  default_font = None


about_text = \
"""Specialized HIstory Viewer
version """ + version + """
Author: rrdrake@sandia.gov"""


############################################################################

class JumpText(Frame):
    """
    The JumpText widget receives text, text anchors and links to those anchors
    and displays the text with the links highlighted.  When a link is clicked,
    the view in the widget will jump to show the location of the associated
    anchor.  In other words, JumpText is a simple hypertext display that only
    understands links within the text.  A scrollbar is included on the right.
    """

    def __init__(self, *args, **kwargs):
        """
        The constructor sends any and all arguments to the Tkinter.Frame
        constructor, which can be used to set the preferred size and border
        style.  The only necessary argument is the parent widget, and must
        occur first.
        """

        apply( Frame.__init__, (self,) + args, kwargs )

        self.text = Text(self, setgrid=1, wrap=WORD)
        scroll = Scrollbar(self, command=self.text.yview)
        self.text.configure(yscrollcommand=scroll.set)
        scroll.pack(side=RIGHT, fill=Y)
        self.text.pack(side=LEFT, fill=BOTH, expand=YES)

        self.text.tag_config("jump", foreground="blue", underline=1)
        self.text.tag_bind("jump", "<Enter>", self._show_hand_cursor)
        self.text.tag_bind("jump", "<Leave>", self._show_arrow_cursor)
        #self.text.tag_bind("jump", "<Button-1>", self._click)
        self.text.tag_bind("jump", "<ButtonRelease>", self._click)

        self.text.config(cursor="")

        self.anchors = {}

    def addText(self, text):
        """
        Add any text which may contain newlines.
        """
        self.text.insert(END, text)

    def addAnchor(self, anchor_name):
        """
        Define an anchor at the current location.
        """
        self.anchors[ anchor_name ] = self.text.index( END )

    def addLink(self, link_text, anchor_name):
        """
        Add a link that points to an anchor location.  The anchor name does
        not have to be defined yet.  The link_text is shown as highlighted,
        underlined, blue text.
        """
        self.text.insert( INSERT, link_text, ("jump", anchor_name) )

    def _show_hand_cursor(self, event):
        if event.widget == self.text:
          self.text.configure(cursor="hand2")

    def _show_arrow_cursor(self, event):
        if event.widget == self.text:
          self.text.configure(cursor="")

    def _click(self, event):
        if event.widget == self.text:
          tags = self.text.tag_names("@%d,%d" % (event.x, event.y))
          if len(tags) > 0 and tags[0] == "jump":
            assert len(tags) > 1
            anchorname = tags[1]
            if self.anchors.has_key( tags[1] ):
              self.text.see( self.anchors[tags[1]] )


############################################################################

manual_break = """

===========================================================

"""

def displayManual(root_widget):

    t = Toplevel(root_widget)
    jt = JumpText(t)
    jt.pack(fill=BOTH, expand=YES)

    jt.addText( \
"""
                    shiv: Specialized HIstory Viewer

  The shiv script reads and displays specialized data coming from a time stepping differential equation solver.  There are three categories of data:

   1) the values of variables at points in the mesh (ie, tracers)
   2) variables associated with each material in the simulation
   3) variables global to the entire mesh

These variable values are shown on the vertical axis and time values on the horizontal axis.  The points and materials are identified by an integer value.  Additionally, there is a flag associated with points indicating an Eularian point, a Lagrangian point, or an ALE point.

  For maximum portability and ease of development, the shiv script is written in the python scripting language using the Tkinter library (which is a wrapper around the tcl/tk libraries).  See the man page for more information about requirements and installation of tcl/tk and python. """ )

    jt.addText( manual_break )

    jt.addText( "  1) " )
    jt.addLink( "Show me the man page.", "manpage" )
    jt.addText( "\n  2) " )
    jt.addLink( "Why was shiv written?", "whywritten" )
    jt.addText( "\n  3) " )
    jt.addLink( "How do I select variables to view?", "selectvars" )
    jt.addText( "\n  4) " )
    jt.addLink( "What are those numbers at the bottom?", "number" )
    jt.addText( "\n  5) " )
    jt.addLink( "How do I move the legend?", "movelegend" )
    jt.addText( "\n  6) " )
    jt.addLink( "How do I remove the legend?", "removelegend" )
    jt.addText( "\n  7) " )
    jt.addLink( "How do I zoom in and zoom out?", "zoom" )
    jt.addText( "\n  8) " )
    jt.addLink( "How do I compare two or more files?", "cmpfiles" )
    jt.addText( "\n  9) " )
    jt.addLink( "How do I save a graph to disk?", "savegraph" )
    jt.addText( "\n 10) " )
    jt.addLink( "What input formats are supported?", "inputformats" )
    jt.addText( "\n 11) " )
    jt.addLink( "What export formats are supported?", "exportformats" )
    jt.addText( "\n 12) " )
    jt.addLink( "Can I do logarithmic plots?", "logplots" )
    jt.addText( "\n 13) " )
    jt.addLink( "Can any variable be plotted against any other?", "anyvar" )
    jt.addText( "\n 14) " )
    jt.addLink( "What batch (non-interactive) operations can be done?", "batch" )
    jt.addText( "\n 15) " )
    jt.addLink( "Can I save my preferences across invocations?", "prefs" )
    jt.addText( "\n 16) " )
    jt.addLink( "Explain the right hand side axis.", "rhsaxis" )

    jt.addText( manual_break )
    jt.addAnchor( "manpage" )
    jt.addText( """
  1) Show me the man page.
""" + manpage )

    jt.addText( manual_break )
    jt.addAnchor( "whywritten" )
    jt.addText( """
  2) Why was shiv written?

  For maximum portability and ease of use.

  There are certainly a number of capable X-Y graphing tools available which can produce high quality figures.  There are also mesh data visualizaton tools with a plethora of features.  Unfortunately, the generality and abundance of features makes it difficult to use these tools, either because of the time investment needed to learn them or because of the shear number of mouse clicks and/or scripting needed to produce the desired graphs.  Portability may also present a significant difficulty, either because a commercial license is needed or because it is difficult to obtain and build the dependencies and source code for a given platform (even if it is a "supported" platform).

  The shiv script was written to provide a very easy to use and very portable solution for a specific visualization need.  This specialization is for tracer, material global and mesh global data arising from time stepping simulation codes.  The goal is to quickly and easily visualize history data by developers and end users.  As such, fancy features and cool graphics are low priority.  For example, no effort has been spent producing publication quality output.
""" )

    jt.addText( manual_break )
    jt.addAnchor( "selectvars" )
    jt.addText( """
  3) How do I select variables to view?

  After a file is read in, there will be a button showing in the lower left corner whose label contains the file name.  Pressing this button will create a separate window containing all the variables contained in the file.  The window columns are "Point ID", "Point Variable", "Material ID", "Material Variable", and "Global Variable".

  For point variables, choose one or more point IDs to show, then select one or more point variables.  The point IDs are shown as a pair -- a unique integer and a integer flag.  The flag indicates the type of point, such as Eularian, Lagrangian or ALE.

  Material variables are similar, except that there is no flag.  To choose a material variable, select one or more material IDs, then choose one or more material variable names.

  Global variables do not have an ID associated with them.  To choose a global variable, select one or more global variable names.
""" )

    jt.addText( manual_break )
    jt.addAnchor( "number" )
    jt.addText( """
  4) What are those numbers at the bottom?

  That pair of numbers that keeps changing at the bottom of the window is the (x,y) values at the location of the mouse coordinates.  So if you hover the mouse over a location on the graph, you can see to high precision what the value of the variable is there.  This applies to any variables that are being shown at the time.  That is, it really shows the vertical value of the mouse on the graph and is not specific to a given variable.
""" )

    jt.addText( manual_break )
    jt.addAnchor( "movelegend" )
    jt.addText( """
  5) How do I move the legend?

  The legend can be moved around by selecting it with the mouse.  Click and hold the mouse over the legend then drag the legend to a new location.
""" )

    jt.addText( manual_break )
    jt.addAnchor( "removelegend" )
    jt.addText( """
  6) How do I remove the legend?

  At this time, the legend cannot be removed.  Try moving the legend to the extreme edge of the window so that not much of it can be seen.
""" )

    jt.addText( manual_break )
    jt.addAnchor( "zoom" )
    jt.addText( """
  7) How do I zoom in and zoom out?

  Zooming in is done by mouse.  Click the mouse button somewhere on the window and hold it, then drag the mouse to make a rectangle.  When the mouse button is released, a zoom in is performed.  Note that the rectangle must reach a certain (small) size before a zoom results.  What actually happens is that the rectangle selects a set of data points and new limits are determined based on the minimums and maximums of the data points.  However, if the control key is held down during this operation, the limits are determined directly from the actual size of the highlighted rectangle.

  There is not really a zoom out mechanism.  However, to reset the zoom, press the "Zoom Reset" button on the lower right.
""" )

    jt.addText( manual_break )
    jt.addAnchor( "cmpfiles" )
    jt.addText( """
  8) How do I compare two or more files?

  More than one file can be given on the command line, or select "File, Overlay File" from the menu bar.  When more than one file button is showing in the lower left, press to bring up the variable lists.  The same or different variables can be chosen from each file and they will be shown on the same graph.

  There is special selection behavior for multiple files.  Selecting (deselecting) variables in the first file will propogate that selection (deselection) to all other file variable lists (if the variable is contained in their variable list, of course).  However, selecting or deselecting variables for files other than the first one will not propogate.
""" )

    jt.addText( manual_break )
    jt.addAnchor( "savegraph" )
    jt.addText( """
  9) How do I save a graph to disk?

  Postscript output can be written to disk by choosing the "File, Output Postscript (Portrait)" or "File, Output Postscript (Landscape)" menu items.  There are also PNG and JPG formats which assume that the ghostscript program called "gs" is installed on your system.  More information about ghostscript is at http://pages.cs.wisc.edu/~ghost/ as of Sept 2007 (or just google "ghostscript").
""" )

    jt.addText( manual_break )
    jt.addAnchor( "inputformats" )
    jt.addText( """
 10) What input formats are supported?

  The "native" format for shiv is an ASCII form of the CTH HISPLT format.  Binary CTH HISPLT formatted files can also be read, even if the file was written on a different platform than it is being read.  As an alternative, binary CTH HISPLT formatted files can be read with program called histoa that is available which converts binary HISPLT format to ASCII which can then be parsed by shiv.  Note that histoa must be run on the same platform as the program that wrote the data (or at least compatible enough).  Files that start with "hct*" or end with ".his*" will be read as a binary HISPLT file.

  Plain tabular files and comma separated values ASCII files can also be read.  Tabular files must have a .txt extension and comma separated values files must have a .csv extension.  In either case, any number of blank lines and/or comment lines can preceed the data (a # sign is a comment character).  The first non-comment line can be the column labels, but is not required.  The first line following the labels can be unit specifications for each variable, but is not required.  All rows must have the same number of columns.  The data ends when the end of the file is reached or a row does not contain enough columns of data (such as a blank line).  The first column is assumed to be time.

  The NetCDF-based Exodus II format can also be read, although only the global variables are extracted.  In order to read Exodus II, the ncdump program packaged with NetCDF must be in your path when you run shiv.  Files that end in ".exo" or ".base_exo" or "e" will be read as an Exodus file.

  The ASCII format is newline based and uses codes to describe each section of data. Each section starts on a new line with one of the following:

  CODE=-100 NUMLINES <num lines>
     The next <num lines> contain the title.
  CODE=-101 NUMLINES <num lines>
     The next <num lines> contain an arbitrary QA string.
  CODE=-102
     The next line contains the numbers of points, materials, and variables.
     It will have syntax (all on the same line):
       NUMPOINTS <nump> NUMMATERIALS <numm> NUMPOINTVARS <numpv>
                            NUMMATERIALVARS <nummv> NUMGLOBALVARS <numgv>
  CODE=-103
     This section lists the variable names, unit strings, point IDs, and
     material IDs.  First comes the point variable names; one line per
     point variable with syntax
       POINTVAR <var name> UNITS <unit string>
     Then comes material variables; one line per variable with syntax
       MATVAR <var name> UNITS <unit string>
     Then comes global variables; one line per variable with syntax
       GLOBALVAR <var name> UNITS <unit string>
     Then comes the point IDs and their associated types; one line per
     point ID with syntax
       POINTID <int ID> TYPE <int type>
     Lastly, the material IDs; one material per line with syntax
       MATERIALID <int ID>
  CODE=100 ====================
     This section contains the values of all variables for a single time
     step dump.  The equals signs are just to help visually mark the
     location in the file.  The next four lines after the code contain the
     the cycle number, time value, time step value, and CPU time:
       CYCLE <int cycle>
       TIME <double time>
       TIMESTEP <double time step>
       CPUTIME <double CPU time>
     The next set of lines contain the point variable values (all on one
     line) one line per point
       POINTS <double for var one> <double for var two> ...
       ...
     The next set of lines contain the material variable values (all on
     one line) one line per material
       MATERIALS <double for var one> <double for var two> ...
       ...
     The next and last line contains the global variable values (all on
     one line).  There is only one line of global data.
       GLOBALS <double for var one> <double for var two> ...

Note that a CODE=-101 (QA string) and CODE=100 (data dump) may appear at any time.  The other codes only appear at the beginning of the file.
""" )

    jt.addText( manual_break )
    jt.addAnchor( "exportformats" )
    jt.addText( """

  11) What output formats are supported?

  When variables for a graph are selected, the data for them can be written out to various text file formats.  Currently, the formats are:

     Tabular Text: contains the time values in the first column followed by each variable in subsequent columns.
     Tabular CSV: same as Tabular Text except the columns are separated by commas.
     XMGR Format: multiple (x,y) arrays are written in a format that the xmgrace program will understand.

  Note that only the XMGR format will support data from multiple files.  Also, the order of the data in the columns of tabular formats is the same as what appears in the legend of shiv.
""" )

    jt.addText( manual_break )
    jt.addAnchor( "logplots" )
    jt.addText( """

  12) Can I do logarithmic plots?

  The data can be transformed to log base 10 by selecting the appropriate check box under the "Axis" menu.  If any data points are less than or equal to zero, they are ignored (left out).  If all of them are less than or equal to zero, then the log base 10 of the absolute value is performed instead.
""" )

    jt.addText( manual_break )
    jt.addAnchor( "anyvar" )
    jt.addText( """

  13) Can any variable be plotted against any other?

  Yes, any variable can be chosen to be shown on the X-Axis.  The default is time.  The X-Axis variable is selected by using the "Axis" menu item, then clicking "Select X-Axis Variable".  A new window will pop up with the variables listed just like the Y-Axis variable chooser.

  Note that more than one X-Axis variable can be chosen.  Also note that at this time, only the variables in the first file will show up in the list.
""" )

    jt.addText( manual_break )
    jt.addAnchor( "batch" )
    jt.addText( """

  14) What batch (non-interactive) operations can be done?

  Variable values can be extracted from a history file and written to standard out in one of the supported text export formats (tabular, comma separated values, and XMGR).  The -b option puts shiv into batch mode and the -p, -m, and -g options are used to specify the variables to extract.  See the man page for more explanation of these options.  The point variables are processed first, then the material, then the global.  Order among these three types is preserved from the command line.

  To specify the output format, use one of the --csv, --tab, or --xmgr options.  The --tab format is the default.  Note that as with """ )
    jt.addLink( "export formats", "exportformats" )
    jt.addText( """ in general, only the XMGR format will support data from multiple files.

  As an example, "shiv -b -p 12/VELOCITYX -p 12/ACCELERATIONX -m 100/KIN-ENERGY -g TIME-STEP -g CPU file.his" would extract the X velocity and acceleration from tracer point 12, kinetic energy from material 100, and the time step size and CPU time all from the file called file.his and the output format would be tabular text.
""" )

    jt.addText( manual_break )
    jt.addAnchor( "prefs" )
    jt.addText( """

  15) Can I save my preferences across invocations?

  Yes.  Anytime you click on a Preferences menu item, a .shivrc file will be written to your home directory with all your current preference values.  When shiv is launched again, it reads those preferences during startup.  (Currently preference saving only works on UNIX.)
""" )

    jt.addText( manual_break )
    jt.addAnchor( "rhsaxis" )
    jt.addText( """

  16) Explain the right hand side axis.

  The Preferences have a "Use Right Hand Axis" selection, which if active, will enable the use of another Y axis which is scaled independently from the left hand axis.  When the left and right hand axes have different scales, the right hand labels are background shaded with grey.  The legend indicates the variables that are scaled according to the right hand axis by also being background shaded in grey.  There is logic that attempts to select which variables are put on the left and right axis.  First, if the variable names are the same, they are put on the same axis.  Second, if the limits of a variable are similar to one of the axes, it is placed on that axis.  Lastly, if neither of these occurs, then the variable is placed on the left axis.
""" )



############################################################################

class ShivMenu(Frame):

    def __init__(self, *args, **kwargs):
        """
        The arguments to ShivMenu must include the parent widget then
        optionally  any arguments that Tkinter.Frame understands.
        For example,
          root = Tk()
          menu = ShivMenu( root, borderwidth=2, relief=RAISED )
        """
        apply( Frame.__init__, (self,) + args, kwargs)
        self._construct()
        self.save_dir = None
        self.dataman = None

    def setWidgets(self, dataman, statusbar):
        self.dataman = dataman
        self.statusbar = statusbar

    def File_Open_callback(self):
        fname = self._openFile(0)

    def File_Overlay_callback(self):
        fname = self._openFile(1)

    def File_Reread_callback(self):
        self.dataman.rereadData()

    def _openFile(self, overlay):
        warnstr = ''
        try:
          title = "Open History File"
          if self.save_dir == None:
            f = askopenfilename( title=title, initialdir=os.getcwd() )
          else:
            f = askopenfilename( title=title, initialdir=self.save_dir )
        except:
          warnstr = "File open capability disabled.  Something is wrong " + \
             "with tkFileDialog.  Use the shiv command line to read files."
        else:
          if f:
            self.save_dir = os.path.dirname(f)
            if not overlay:
              self.dataman.clearData()
              self.statusbar.clearFileButtons()
            errstr = ''
            try:
              ids = self.dataman.addFileData( FileData(f, \
                                                opts.get('--skip',None)) )
              self.statusbar.addFileButton( ids,
                    lambda event, dm=self.dataman, fn=ids: dm.showChooser(fn) )
            except IOError, e:
              errstr = str(e)
            if errstr:
              try:
                showerror( title="shiv Read Error",
                      message="Could not read file:\n" + f + "\n" + errstr )
              except:
                print "*** shiv: could not read file:", errstr
        if warnstr:
          try:
            showwarning( title="shiv Warning", message=warnstr )
          except:
            print "*** shiv: warning: " + warnstr

    def File_Print_callback_portrait(self):
        self.File_Print(0)

    def File_Print_callback_landscape(self):
        self.File_Print(1)

    def File_PrintPNG_callback(self):
        self.File_Print(0, ".png")

    def File_PrintJPG_callback(self):
        self.File_Print(0, ".jpg")

    def File_Print(self, landscape, fmt=".eps"):
        warnstr = ''
        try:
          title = "Output " + fmt + " File"
          if self.save_dir == None:
            f = asksaveasfilename( title=title, defaultextension=fmt,
                                   initialdir=os.getcwd() )
          else:
            f = asksaveasfilename( title=title, defaultextension=fmt,
                                   initialdir=self.save_dir )
        except Exception, e:
          print e
          warnstr = "Print capability disabled.  Your version of python " + \
            "does not have tkFileDialog (or the interface to it is unexpected)."
        else:
          if f:
            errstr = ''
            self.save_dir = os.path.dirname(f)
            errstr = self.dataman.printToFile( f, landscape, fmt )
            if errstr:
              try:
                showerror( title="shiv Output Error",
                      message="Could not output file " + f + ":\n" + errstr )
              except:
                print "*** shiv: could not output file:", errstr
        if warnstr:
          try:
            showwarning( title="shiv Warning", message=warnstr )
          except:
            print "*** shiv: warning: " + warnstr

    def File_Quit_callback(self):
        self.quit()

    def File_Tabular_callback(self):
        self._exportCallback( ".txt", "tab", "Tabular" )

    def File_TabularCSV_callback(self):
        self._exportCallback( ".csv", "csvtab", "CSV Tabular" )

    def File_XMGR_callback(self):
        self._exportCallback( ".xmgr", "xmgr", "XMGR Format" )

    def _exportCallback(self, extension, format, description):
        warnstr = ''
        try:
          title = "Export " + description + " File"
          if self.save_dir == None:
            f = asksaveasfilename( title=title, defaultextension=extension,
                                   initialdir=os.getcwd() )
          else:
            f = asksaveasfilename( title=title, defaultextension=extension,
                                   initialdir=self.save_dir )
        except Exception, e:
          print e
          warnstr = "Export capability disabled.  Your version of python " + \
            "does not have tkFileDialog (or the interface to it is unexpected)."
        else:
          if f:
            errstr = ''
            self.save_dir = os.path.dirname(f)
            try:
              fileobj = open( f, "w" )
            except:
              errstr = "Failed to open file for write"
            else:
              errstr = self.dataman.export(fileobj, format)
              fileobj.close()
            if errstr:
              try:
                showerror( title="shiv Export " + description + " Error",
                      message="Could not output file " + f + ":\n" + errstr )
              except:
                print "*** shiv: could not export file:", errstr
        if warnstr:
          try:
            showwarning( title="shiv Warning", message=warnstr )
          except:
            print "*** shiv: warning: " + warnstr

    def Axis_LogY_callback(self):
        self.dataman.setLogY( self.logyvar.get() )
        self.dataman.resetData()

    def Axis_LogX_callback(self):
        self.dataman.setLogX( self.logxvar.get() )
        self.dataman.resetData()

    def Axis_Scale_callback(self):
        self.dataman.setScale( self.scalevar.get() )
        self.dataman.resetData()

    def Axis_XVar_callback(self):
        self.dataman.showXAxisChooser()

    def View_ZUndo_callback(self):
        self.dataman.zoomBack()

    def View_ZReset_callback(self):
        self.dataman.refreshZoom()

    def View_GHistory_callback(self):
        if not self.dataman.switchView( DATAVIEW_HISTORY ):
          data_view.set( self.dataman.view )

    def View_XYZProfile_callback(self):
        if not self.dataman.switchView( DATAVIEW_PROFILE ):
          data_view.set( self.dataman.view )

    def View_PHistory_callback(self):
        if not self.dataman.switchView( DATAVIEW_POINTS ):
          data_view.set( self.dataman.view )

    def Prefs_UseSymbols_callback(self):
        # TODO: see if the symbols can be removed without going through
        #       a complete refresh
        self.dataman.resetData(0)
        writePrefs()

    def Prefs_AutoZoom_callback(self):
        writePrefs()

    def Prefs_RHSAxis_callback(self):
        self.dataman.shivcanv.resetInsets()
        self.dataman.resetData()
        writePrefs()

    def Prefs_Clip_callback(self):
        self.dataman.resetData(0)

    def Help_About_callback(self):
        t = Toplevel(self)
        t.transient(self)
        Label(t, text=about_text).pack( padx=10, pady=10 )
        b = Button(t, text="OK", command=t.destroy)
        b.pack( side=BOTTOM, padx=10, pady=10 )

    def Help_Manual_callback(self):
        displayManual(self)

    def _construct(self):

        self.filemenu = Menubutton( self, text="File" )
        self.filemenu.pack( side=LEFT, padx="2m" )
        self.filemenu.menu = Menu( self.filemenu, tearoff=0 )
        self.filemenu.menu.add_command( \
               label="Open File", command=self.File_Open_callback )
        self.filemenu.menu.add_command( \
               label="Overlay File", command=self.File_Overlay_callback )
        self.filemenu.menu.add_command( \
               label="Reread Files", command=self.File_Reread_callback )
        self.filemenu.menu.add_separator()
        self.filemenu.menu.add_command( \
               label="Output Postscript (Portrait)",
               command=self.File_Print_callback_portrait )
        self.filemenu.menu.add_command( \
               label="Output Postscript (Landscape)",
               command=self.File_Print_callback_landscape)
        self.filemenu.menu.add_command( \
               label="Output PNG",
               command=self.File_PrintPNG_callback )
        self.filemenu.menu.add_command( \
               label="Output JPG",
               command=self.File_PrintJPG_callback )
        self.filemenu.menu.add_separator()
        self.filemenu.menu.add_command( \
               label="Export Tabular Text", command=self.File_Tabular_callback )
        self.filemenu.menu.add_command( \
               label="Export Tabular CSV", command=self.File_TabularCSV_callback )
        self.filemenu.menu.add_command( \
               label="Export XMGR Format", command=self.File_XMGR_callback )
        self.filemenu.menu.add_separator()
        self.filemenu.menu.add_command( \
               label="Quit", command=self.File_Quit_callback )
        self.filemenu['menu'] = self.filemenu.menu

        self.viewmenu = Menubutton( self, text="View" )
        self.viewmenu.pack( side=LEFT, padx="2m" )
        self.viewmenu.menu = Menu( self.viewmenu, tearoff=0 )
        self.viewmenu.menu.add_command( \
               label="Zoom Undo", command=self.View_ZUndo_callback )
        self.viewmenu.menu.add_command( \
               label="Zoom Reset", command=self.View_ZReset_callback )
        self.viewmenu.menu.add_separator()
        self.viewmenu.menu.add_radiobutton( \
               label="Global Histories", command=self.View_GHistory_callback,
               variable=data_view, value=DATAVIEW_HISTORY )
        self.viewmenu.menu.add_radiobutton( \
               label="X/Y/Z Profiles", command=self.View_XYZProfile_callback,
               variable=data_view, value=DATAVIEW_PROFILE )
        self.viewmenu.menu.add_radiobutton( \
               label="Pointwise Histories", command=self.View_PHistory_callback,
               variable=data_view, value=DATAVIEW_POINTS )
        self.viewmenu['menu'] = self.viewmenu.menu

        self.axismenu = Menubutton( self, text="Axis" )
        self.axismenu.pack( side=LEFT, padx="2m" )
        self.axismenu.menu = Menu( self.axismenu, tearoff=0 )
        self.logyvar = IntVar(); self.logyvar.set(0)
        self.axismenu.menu.add_checkbutton( \
               label="Log10 on Y-Axis", command=self.Axis_LogY_callback,
               variable=self.logyvar )
        self.logxvar = IntVar(); self.logxvar.set(0)
        self.axismenu.menu.add_checkbutton( \
               label="Log10 on X-Axis", command=self.Axis_LogX_callback,
               variable=self.logxvar )
        self.scalevar = IntVar(); self.scalevar.set(0)
        self.axismenu.menu.add_checkbutton( \
               label="Normalize Y-Axis values", \
               command=self.Axis_Scale_callback, variable=self.scalevar )
        self.axismenu.menu.add_command( \
               label="Select X-Axis Variable", \
               command=self.Axis_XVar_callback )
        self.axismenu['menu'] = self.axismenu.menu

        self.prefsmenu = Menubutton( self, text="Preferences" )
        self.prefsmenu.pack( side=LEFT, padx="2m" )
        self.prefsmenu.menu = Menu( self.prefsmenu, tearoff=0 )
        self.prefsmenu.menu.add_checkbutton( \
               label="Use Line Symbols", command=self.Prefs_UseSymbols_callback,
               variable=use_symbols )
        self.prefsmenu.menu.add_checkbutton( \
               label="Auto Zoom Reset", command=self.Prefs_AutoZoom_callback,
               variable=auto_zoom )
        self.prefsmenu.menu.add_checkbutton( \
               label="Use Right Hand Axis", command=self.Prefs_RHSAxis_callback,
               variable=rhs_axis )
        self.prefsmenu.menu.add_checkbutton( \
               label="Clip to Plot Window",
               command=self.Prefs_Clip_callback,
               variable=plot_clip )
        self.prefsmenu['menu'] = self.prefsmenu.menu

        self.helpmenu = Menubutton( self, text="Help" )
        self.helpmenu.pack( side=RIGHT, padx="2m" )
        self.helpmenu.menu = Menu( self.helpmenu, tearoff=0 )
        self.helpmenu.menu.add_command( \
               label="About", command=self.Help_About_callback )
        self.helpmenu.menu.add_command( \
               label="Manual", command=self.Help_Manual_callback )
        self.helpmenu['menu'] = self.helpmenu.menu


############################################################################


class TickList:

    def __init__(self, wleft=None, wright=None):
        self.values = []
        self.labels = []
        if wleft != None and wright != None:
          self.setTicks( wleft, wright, 0 )

    def setTicks(self, wleft, wright, log):
        """
        Computes and sets tick mark values and labels for the given left
        and right marks.  The left may be pushed further left and right
        further right if it makes the tick mark land on a "nice" value.
        """
        wleft = float(wleft)
        wright = float(wright)

        assert wleft <= wright

        self.values = []
        self.labels = []

        if log and wleft > 0.0:

          order, power = self.computeOrder( wleft )

          M = wright - wleft
          if M < SMALL_FLOAT:
            M = 0.0
          else:
            M = M * 0.001

          t = order
          while t < wright - M:
            self.values.append( t )
            self.labels.append( "%.0e" % t )
            t = t * 10.0
          self.values.append( t )
          self.labels.append( "%.0e" % t )

        else:

          absL = abs( wleft )
          absR = abs( wright )
          absBig = max( absL, absR )
          absSmall = min( absL, absR )

          if absSmall < absBig * 0.101:
            # use a technique that works well when the smaller number can be
            # treated as zero compared to the bigger
            order, power = self._dominate( wleft, wright )
          else:
            diff = wright - wleft
            if diff > absBig * 0.101:
              # use a technique that works well when the difference is on the
              # same order of magnitude as the biggest value
              order, power = self._sameMag( wleft, wright )
            else:
              # fallback to a technique that works for any two values
              order, power = self._fallback( wleft, wright )

          # determine the minimum number of digits after the decimal so that
          # all tick mark labels are different between successfive ticks
          ndig = 1
          while ndig <= 6:
            enough = 1
            s1 = ''
            if power >= -1 and power <= 2:
              fmt = "%." + str(ndig) + "f"
              for t in self.values:
                s2 = fmt % t
                if s1 == s2:
                  enough = 0
                  break
                s1 = s2
            else:
              fmt = "%." + str(ndig) + "fe%d"
              for t in self.values:
                s2 = fmt % (t/order,power)
                if s1 == s2:
                  enough = 0
                  break
                s1 = s2
            if enough:
              break
            ndig = ndig + 1

          ndig = ndig + 1
          if power >= -1 and power <= 2:
            fmt = "%." + str(ndig) + "f"
            for t in self.values:
              self.labels.append( fmt % t )
          else:
            fmt = "%." + str(ndig) + "fe%d"
            for t in self.values:
              self.labels.append( fmt % (t/order,power) )

    def computeOrder(self, x):
        """
        Determines the floating point number, y, equal to 10 to the p-th power
        such that y <= x and 10*y > x.  For example, 1.1 would be 1.0, 0.9
        is 0.1, 101.1 is 100.0, 1.e-9 is 1.e-9, and 5.e-9 is 1.e-9.
        Returns this value and the power, p.
        """
        x = float( abs(x) )

        y = 1.0
        p = 0

        if x < 1.0:
          if x < SMALL_FLOAT:
            y = SMALL_FLOAT
            p = SMALL_POWER
          else:
            while 1:
              y = y / 10.0
              p = p - 1
              if y - x < SMALL_FLOAT:
                break

        else:
          while 1:
            y = y * 10.0
            p = p + 1
            if y > x - SMALL_FLOAT:
              y = y / 10.0
              p = p - 1
              break

        assert y >= SMALL_FLOAT
        assert (y - x) < SMALL_FLOAT and (x - 10*y) < SMALL_FLOAT

        return y, p

    def _dominate(self, wleft, wright):

        order, power = self.computeOrder( max( abs(wleft), abs(wright) ) )

        diff = wright - wleft

        iL = 0.0
        while iL > wleft+diff/1000.0: iL = iL - order
        iR = 0.0
        while iR < wright-diff/1000.0: iR = iR + order
        t = iL
        while t < iR + diff/100.0:
          self.values.append( t )
          t = t + order

        subdiv = 0
        while len(self.values) < 5 and subdiv < 4:
          self.values = []
          if subdiv == 0: order2 = order
          elif subdiv == 1: order2 = order/2.0
          elif subdiv == 2: order2 = order/5.0
          elif subdiv == 3: order2 = order/10.0
          iL = 0.0
          while iL > wleft+diff/1000.0: iL = iL - order2
          iR = 0.0
          while iR < wright-diff/1000.0: iR = iR + order2
          t = iL
          while t < iR + diff/100.0:
            self.values.append( t )
            t = t + order2
          subdiv = subdiv + 1

        return order, power

    def _sameMag(self, wleft, wright):

        diff = wright - wleft

        order, power = self.computeOrder( diff )

        Ltick = 0.0
        if wleft < 0.0:
          while Ltick > wleft+diff/1000.0: Ltick = Ltick - order
        else:
          while Ltick < wleft-diff/1000.0: Ltick = Ltick + order
          Ltick = Ltick - order

        t = Ltick
        while t < wright-diff/100.0:
          self.values.append(t)
          t = t + order
        self.values.append(t)

        subdiv = 0
        while len(self.values) < 5:
          self.values = []
          if subdiv == 0: order2 = order
          elif subdiv == 1: order2 = order/2.0
          elif subdiv == 2: order2 = order/5.0
          elif subdiv == 3: order2 = order/10.0
          Ltick = 0.0
          if wleft < 0.0:
            while Ltick > wleft+diff/1000.0: Ltick = Ltick - order2
          else:
            while Ltick < wleft-diff/1000.0: Ltick = Ltick + order2
            Ltick = Ltick - order2
          t = Ltick
          while t < wright-diff/100.0:
            self.values.append(t)
            t = t + order2
          self.values.append(t)
          subdiv = subdiv + 1

        return order, power

    def _fallback(self, wleft, wright):

        wleft, wright = adjustRange( wleft, wright )

        diff = wright - wleft

        step = diff/4.0

        order, power = self.computeOrder( max( abs(wleft), abs(wright) ) )

        self.values.append( wleft )
        t = wleft
        while t < wright - diff/100.0:
          t = t + step
          self.values.append(t)

        return order, power


def adjustRange( L, R ):
    """
    If left and right are equal or nearly equal, then a new left and right
    are returned that have a reasonable separation.  Otherwise the original
    values are returned.
    """
    M = max( abs(float(L)), abs(float(R)) )
    diff = float(R) - float(L)
    if diff < SMALL_FLOAT or diff < 1.e-6 * M:
      if M < SMALL_FLOAT:
        return float(L) - SMALL_FLOAT, float(R) + SMALL_FLOAT
      else:
        return float(L) - 1.e-6 * M, float(R) + 1.e-6 * M
    return float(L), float(R)


############################################################################

class Transformer:
    """
    Transforms world floating point coordinates and plot coordinates into
    Tkinter.Canvas integer coordinates.

    The origin of the canvas coordinates is at the top left and the units
    are in pixels.

                             -----> x+ (from 0 to width)
                             |
                             |
                             v y+ (from 0 to height)

    The origin of the plot coordinates are lower left adjusted by insets
    and the units are in pixels.

                             ______________________
                 top inset __|  ________________   |
                             |  ^               |  |
                             |  |y+             |  |
                             |  |    x+         |  |
              bottom inset __|  o-------------->|  |
                             |_____________________|
                                |               |
                             left inset    right inset

    The world coordinates are defined by (xmin,ymin) on the lower left and
    (xmax,ymax) on the upper right.  They are mapped to canvas pixels within
    the inset box.

    If the canvas coordinates are denoted (Cx,Cy) and the plot coordinate by
    (Px,Py) then the relationship between them is

             Cx = Px + L
             Cy = Cheight - Py - B

    where:   L = left inset
             R = right inset
             B = bottom inset
             T = top inset
             Cwidth = canvas width in pixels
             Cheight = canvas height in pixels

    If the world coordinates are denoted (x,y) then the relationship between
    the world coordinates and canvas coordinates is

             Cx = L + xratio * (x - xmin)
             Cy = Cheight - B - yratio * (y -ymin)

    where:             Cwidth - L - R
             xratio = -----------------
                         xmax - xmin

                       Cheight - B - T
             yratio = -----------------
                         ymax - ymin

    The x() and y() method function of this class transform world coordinates
    into canvas coordinates.  The px() and py() method functions transform
    plot coordinates into canvas coordinates.
    """

    def __init__(self):
        self.size = [ 100, 75 ]  # width, height
        self.inset = [ 20, 5, 20, 5 ]  # left, right, bottom, top
        self.world = [ 0.0, 1.0, 0.0, 1.0 ]  # Xmin, Xmax, Ymin, Ymax
        self.logx = 0
        self.logy = 0
        self.scale = 0
        self.horiz_ticks = TickList( 0.0, 1.0 )
        self.vert_ticks = TickList( 0.0, 1.0 )
        self._reset()

    def setCanvas(self, canvas_width, canvas_height):
        self.size[0] = canvas_width   ; assert canvas_width > 0
        self.size[1] = canvas_height  ; assert canvas_height > 0
        self._reset()

    def setInsets(self, left, right, bottom, top):
        self.inset[0] = left    ; assert left >= 0
        self.inset[1] = right   ; assert right >= 0
        self.inset[2] = bottom  ; assert bottom >= 0
        self.inset[3] = top     ; assert top >= 0
        self._reset()

    def setLogX(self, value): self.logx = value
    def setLogY(self, value): self.logy = value
    def setScale(self, value): self.scale = value

    def setWorld(self, xmin, xmax, ymin, ymax):
        assert xmin < xmax and ymin < ymax
        self.horiz_ticks.setTicks( xmin, xmax, self.logx )
        self.world[0] = min( xmin, self.horiz_ticks.values[0] )
        self.world[1] = max( xmax, self.horiz_ticks.values[-1] )
        self.vert_ticks.setTicks( ymin, ymax, self.logy )
        self.world[2] = min( ymin, self.vert_ticks.values[0] )
        self.world[3] = max( ymax, self.vert_ticks.values[-1] )
        self._reset()

    def forceWorld(self, xmin, xmax, ymin, ymax):
        assert xmin < xmax and ymin < ymax
        self.world[0] = xmin
        self.world[1] = xmax
        self.world[2] = ymin
        self.world[3] = ymax

    def getHorizTicks(self):
        return self.horiz_ticks.values, self.horiz_ticks.labels

    def getVertTicks(self):
        return self.vert_ticks.values, self.vert_ticks.labels

    # These translate world coordinates into canvas coordinates.
    def x(self, world_x):
        if self.logx and self.world[0] > 0.0:
          return int( self.inset[0] + \
                      self.xratio * float( math.log10(world_x) - \
                                           math.log10(self.world[0]) ) )
        return int( self.inset[0] + \
                    self.xratio * float( world_x - self.world[0] ) )
    def y(self, world_y):
        if not self.scale and self.logy and self.world[2] > 0.0:
          return int( self.size[1] - self.inset[2] - \
                      self.yratio * float( math.log10(world_y) - \
                                           math.log10(self.world[2]) ) )
        return int( self.size[1] - self.inset[2] - \
                    self.yratio * float( world_y - self.world[2] ) )

    # These translate plot coordinates into canvas coordinates.
    def px(self, plot_x):
        return plot_x + self.inset[0]
    def py(self, plot_y):
        return self.size[1] - plot_y - self.inset[2]

    def getWorld(self):
        return self.world[0], self.world[1], self.world[2], self.world[3]

    def halfHorizontal(self):
        return int( self.inset[0] + \
                    float(self.size[0] - self.inset[0] - self.inset[1])/2.0 )

    def plotWidth(self):
        """
        Returns the pixel width within the plotting window inset in the canvas.
        """
        return self.size[0] - self.inset[0] - self.inset[1]

    def plotHeight(self):
        """
        Returns the pixel hight within the plotting window inset in the canvas.
        """
        return self.size[1] - self.inset[2] - self.inset[3]

    # these convert canvas coordinates into world coordinates
    def wx(self, canvas_x):
        if self.logx and self.world[0] > 0.0:
          return math.pow( 10, math.log10(self.world[0]) + \
                               float(canvas_x-self.inset[0]) / self.xratio )
        return self.world[0] + float(canvas_x-self.inset[0]) / self.xratio
    def wy(self, canvas_y):
        if not self.scale and self.logy and self.world[2] > 0.0:
          return math.pow( 10, math.log10(self.world[2]) - \
                 float(canvas_y-self.size[1]+self.inset[2]) / self.yratio )
        return self.world[2] - \
               float(canvas_y-self.size[1]+self.inset[2]) / self.yratio

    def _reset(self):
        if self.logx and self.world[0] > 0.0:
          self.xratio = float( self.size[0] - self.inset[0] - self.inset[1] )/ \
                        float( math.log10(self.world[1]) - \
                               math.log10(self.world[0]) )
        else:
          self.xratio = float( self.size[0] - self.inset[0] - self.inset[1] )/ \
                        float( self.world[1] - self.world[0] )
        if not self.scale and self.logy and self.world[2] > 0.0:
          self.yratio = float( self.size[1] - self.inset[2] - self.inset[3] )/ \
                        float( math.log10(self.world[3]) - \
                               math.log10(self.world[2]) )
        else:
          self.yratio = float( self.size[1] - self.inset[2] - self.inset[3] )/ \
                        float( self.world[3] - self.world[2] )


############################################################################

def fontToList( font_string ):
    L = string.split( font_string )
    i = len(L) - 1
    while i >= 0:
      try: sz = int(L[i])
      except: pass
      else: break
      i = i - 1
    if i > 0:
      fL = [ string.join( L[:i] ) ]
      fL.extend( L[i:] )
      return fL
    # should not reach this point, but return something anyway
    return L

def fontToString( font_list, family=None, size=None, style=None ):
    assert font_list != None
    if family != None: font_list[0] = '"' + family + '"'
    if size != None: font_list[1] = '-' + size
    if style != None:
      if style in font_list[2:]:
        newF = [ font_list[0], font_list[1] ]
        for s in font_list[2:]:
          if style != s:
            newF.append(s)
        font_list = newF
      else:
        font_list.append(style)
    fopt = string.join(font_list)
    return fopt, font_list


def fontInstance( fontL ):
    fnt = None
    if tkFont != None:
#      global default_font
      fnt = default_font
      if fontL != None:
        sz = str(abs(int(fontL[1])))
        if len(fontL) > 2 and 'bold' in string.split(fontL[2]):
          fnt = tkFont.Font( family=fontL[0], size=sz, weight='bold' )
        else:
          fnt = tkFont.Font( family=fontL[0], size=sz )
    else:
      # TODO: handle case before tkFont was available (before tcl/tk 8.0)
      pass
    return fnt


class Axis:

    LEFT_SIDE = 0
    BOTTOM_SIDE = 1
    RIGHT_SIDE = 2

    def __init__(self, side, xform, canv_obj):
        self.side = side
        self.xform = xform
        self.canv_obj = canv_obj

        self.ticks = []   # triples of (value, tick line id, label id)
        self.tickL = None  # list of the values
        self.force_ticks = None
        self.force_labels = None

        self.tick_font = None
        self.addoff = 0

        self.shade_id = None

        self.size = 20  # width or height adjusted for font and tick labels

    def getTicks(self):
        if self.force_ticks != None:
          return self.force_ticks, self.force_labels
        if self.side == Axis.LEFT_SIDE or self.side == Axis.RIGHT_SIDE:
          return self.xform.getVertTicks()
        return self.xform.getHorizTicks()

    def setTickLabels(self, labels_string):
        self.force_ticks = []
        self.force_labels = []
        for s in string.split(labels_string):
          try:
            t = float(s)
          except:
            pass
          else:
            self.force_ticks.append(t)
            self.force_labels.append(s)
        for (t,tid,nid) in self.ticks:
          self.canv_obj.delete( tid )
          self.canv_obj.delete( nid )
        self.ticks = []
        self.tickL = None

    def clear(self):
        """
        Deletes all canvas objects for this axis.
        """
        for (t,tid,nid) in self.ticks:
          self.canv_obj.delete( tid )
          self.canv_obj.delete( nid )
        self.ticks = []
        self.tickL = []
        if self.shade_id != None:
          self.canv_obj.delete( self.shade_id )
          self.shade_id = None
        self.size = 20

    def draw(self, canv_obj):

        tickL, labelL = self.getTicks()

        if self.tickL == None or tickL != self.tickL:
          self._reset( tickL, labelL )

        else:

          if self.shade_id != None:
            # if shade active but same limits is now true, delete shade
            if self.xform.same_limits:
              self.canv_obj.delete( self.shade_id )
              self.shade_id = None
            else:
              push = self.getFontHeight() / 2
              self.canv_obj.coords( self.shade_id,
                        self.xform.px(self.xform.plotWidth())+5,
                        self.xform.py(0)+push,
                        self.xform.size[0],
                        self.xform.py(0)-self.xform.plotHeight()-push )

          # TODO: adjust these for font size
          Loff = self.xform.px(-8)
          Roff = self.xform.px( self.xform.plotWidth() + 8 )
          Boff = self.xform.py(-8) + self.addoff

          for (t,tid,nid) in self.ticks:
            if self.side == Axis.LEFT_SIDE:
              self.canv_obj.coords( tid, self.xform.px(0), self.xform.y(t),
                                    self.xform.px(-5), self.xform.y(t) )
              self.canv_obj.coords( nid, Loff, self.xform.y(t) )
            elif self.side == Axis.RIGHT_SIDE:
              self.canv_obj.coords( tid, self.xform.px(self.xform.plotWidth()),
                                    self.xform.y(t),
                                    self.xform.px(self.xform.plotWidth()+5),
                                    self.xform.y(t) )
              self.canv_obj.coords( nid, Roff, self.xform.y(t) )
            else:
              self.canv_obj.coords( tid, self.xform.x(t), self.xform.py(0),
                                    self.xform.x(t), self.xform.py(-5) )
              self.canv_obj.coords( nid, self.xform.x(t), Boff )

    def getSize(self):
        tickL, labelL = self.getTicks()
        if self.tickL == None or tickL != self.tickL:
          self._computeSize(labelL)
        return self.size

    def getFontHeight(self):
        if self.tick_font == None:
          return 12
        else:
          fopt, self.tick_font = fontToString( self.tick_font )
          fnt = fontInstance( self.tick_font )
          D = fnt.metrics()
          return D['ascent'] + D['descent']

    def setAdditionalOffset(self, off):
        self.addoff = off

    def _computeSize(self, label_list):
        if self.tick_font == None:
          # approximate for Helvitical 12 point
          if self.side == Axis.LEFT_SIDE or self.side == Axis.RIGHT_SIDE:
            self.size = 0
            for txt in label_list:
              w = len(txt)
              if self.size < w: self.size = w
            self.size = self.size*7 + 10
          else:
            self.size = 20
        else:
          fopt, self.tick_font = fontToString( self.tick_font )
          fnt = fontInstance( self.tick_font )
          if self.side == Axis.LEFT_SIDE or self.side == Axis.RIGHT_SIDE:
            self.size = 20
            for txt in label_list:
              w = fnt.measure(txt)
              if self.size < w: self.size = w
            self.size = self.size + 12
          else:
            D = fnt.metrics()
            self.size = D['ascent'] + D['descent']
            if self.size > 14:
              # give more space for larger fonts
              self.size = int(1.2 * self.size)
            self.size = self.size + 4
        self.size = self.size + self.addoff

    def _reset(self, tick_list, label_list):

        self.clear()

        if self.side == Axis.RIGHT_SIDE and rhs_axis.get() and \
           not self.xform.same_limits:
          push = self.getFontHeight() / 2
          self.shade_id = self.canv_obj.create_rectangle( \
                    self.xform.px(self.xform.plotWidth())+5,
                    self.xform.py(0)+push,
                    self.xform.size[0],
                    self.xform.py(0)-self.xform.plotHeight()-push,
                    fill="lightgrey", width=0.0 )

        self.size = 25

        if self.side != Axis.RIGHT_SIDE or rhs_axis.get():

          self._computeSize(label_list)

          assert len(tick_list) == len(label_list)

          if self.tick_font != None:
            fopt, self.tick_font = fontToString( self.tick_font )

          # TODO: adjust these for font size
          Loff = self.xform.px(-8)  # TODO: adjust for font
          Roff = self.xform.px( self.xform.plotWidth() + 8 )
          Boff = self.xform.py(-8) + self.addoff

          for i in range(len(tick_list)):
            t = tick_list[i]
            self.tickL.append(t)

            txt = label_list[i]

            if self.side == Axis.LEFT_SIDE:
              tid = self.canv_obj.create_line( \
                                self.xform.px(0), self.xform.y(t),
                                self.xform.px(-5), self.xform.y(t) )
              nid = self.canv_obj.create_text( Loff, self.xform.y(t),
                                               text=txt, anchor=E )
              self.ticks.append( (t,tid,nid) )
            elif self.side == Axis.RIGHT_SIDE:
              tid = self.canv_obj.create_line( \
                              self.xform.px(self.xform.plotWidth()),
                              self.xform.y(t),
                              self.xform.px(self.xform.plotWidth()+5),
                              self.xform.y(t) )
              nid = self.canv_obj.create_text( Roff, self.xform.y(t),
                                               text=txt, anchor=W )
              self.ticks.append( (t,tid,nid) )
            else:
              tid = self.canv_obj.create_line( \
                                self.xform.x(t), self.xform.py(0),
                                self.xform.x(t), self.xform.py(-5) )
              nid = self.canv_obj.create_text( \
                                self.xform.x(t), Boff, text=txt, anchor=N )
              self.ticks.append( (t,tid,nid) )

            if self.tick_font != None:
              self.canv_obj.itemconfigure( nid, font=fopt )

    def setTickFont(self, family=None, size=None, style=None ):
        if len(self.ticks) > 0:
          t,tid,nid = self.ticks[0]
          self.tick_font = fontToList( self.canv_obj.itemcget(nid, "font") )
          fopt, self.tick_font = fontToString( self.tick_font,
                                      family=family, size=size, style=style )
          for (t,tid,nid) in self.ticks:
            self.canv_obj.itemconfigure( nid, font=fopt )
          tickL, labelL = self.getTicks()
          self._computeSize(labelL)


############################################################################

def lineBoxIntersection( Ax, Ay, Bx, By, L, R, B, T, failx, faily ):
    """
    Point A must be inside the box and B outside.  The box is defined by
    left, right, bottom, top.  If the algorithm fails to find an intersection
    (which is unlikely) then it will return (failx, faily).
    """
    try:

      dx = Bx-Ax
      dy = By-Ay
      xfuz = (R-L)*1.e-4
      yfuz = (T-B)*1.e-4

      x1 = None
      y1 = None
      if By > T:
        # intersect with top line
        x1 = Ax+(dx/dy)*(T-Ay)
        y1 = T
        if x1 > L-xfuz and x1 < R+xfuz:
          return x1, y1

      x2 = None
      y2 = None
      if By < B:
        # intersect with bottom line
        x2 = Ax+(dx/dy)*(B-Ay)
        y2 = B
        if x2 > L-xfuz and x2 < R+xfuz:
          return x2, y2

      x3 = None
      y3 = None
      if Bx < L:
        # intersect with left line
        x3 = L
        y3 = Ay+(dy/dx)*(L-Ax)
        if y3 > B-yfuz and y3 < T+yfuz:
          return x3, y3

      x4 = None
      y4 = None
      if Bx > R:
        # intersect with right line
        x4 = R
        y4 = Ay+(dy/dx)*(R-Ax)
        if y4 > B-yfuz and y4 < T+yfuz:
          return x4, y4

    except:
      pass

    # should not get here, but if so return the fail point
    return failx, faily


class DataLine:

    def __init__(self, xform, points, linetype, label):
        """
        The points argument should be a list of (x,y) pairs in world coords.
        """
        self.xform = xform
        self.linetype = linetype
        self.label = label
        self.points = points  # list of (x,y) pairs
        self.canvas_ids = []  # one or more canvas ids
        self.symbols = []  # list of LineType symbol objects
        self.wbox = None  # a list [ xmin, xmax, ymin, ymax ]
        for (x,y) in points:
          if self.wbox == None:
            self.wbox = [ x, x, y, y ]
          else:
            if x < self.wbox[0]: self.wbox[0] = x
            if x > self.wbox[1]: self.wbox[1] = x
            if y < self.wbox[2]: self.wbox[2] = y
            if y > self.wbox[3]: self.wbox[3] = y

    def getBox(self):
        return [ self.wbox[0], self.wbox[1], self.wbox[2], self.wbox[3] ]

    def rebox(self, minx, maxx, miny, maxy):
        """
        Returns another box consisting of the min and max points of all
        the data that are contained in the given box.
        """
        if len(self.points) > 0:
          xmin = None
          for (x,y) in self.points:
            if x >= minx and x <= maxx and y >= miny and y <= maxy:
              if xmin == None:
                xmin = x ; ymin = y ; xmax = x ; ymax = y
              else:
                if xmin > x: xmin = x
                if ymin > y: ymin = y
                if xmax < x: xmax = x
                if ymax < y: ymax = y
          if xmin != None:
            return [ xmin, xmax, ymin, ymax ]
        return None

    def draw(self, canvas_obj):
        """
        Draws the line plus symbols.  If a point is a distance away from the
        canvas more than 10 times the size of the canvas, the point and line
        is not plotted.  If clipping is turned on, lines that extend outside
        the plot window are not shown (they are truncated to what lies inside
        the box).
        """
        # delete the line and symbols first
        for cid in self.canvas_ids:
          canvas_obj.delete( cid )
        self.canvas_ids = []
        for sid in self.symbols:
          self.linetype.delete( canvas_obj, sid )
        self.symbols = []

        L = self.xform.world[0]
        R = self.xform.world[1]
        w = R - L
        B = self.xform.world[2]
        T = self.xform.world[3]
        h = T - B

        if plot_clip.get() and len(self.points) > 1:

          idL = []
          cpnts = []

          # process first point to get started
          x, y = self.points[0]
          if x >= L and x <= R and y >= B and y <= T:
            inside = 1
            if use_symbols.get():
              symid = self.linetype.draw( canvas_obj,
                                      self.xform.x(x), self.xform.y(y) )
              self.symbols.append(symid)
            cpnts.append( self.xform.x(x) )
            cpnts.append( self.xform.y(y) )
          else:
            inside = 0

          i = 1
          while i < len(self.points):
            x = self.points[i][0]
            y = self.points[i][1]
            if x >= L and x <= R and y >= B and y <= T:
              if use_symbols.get():
                symid = self.linetype.draw( canvas_obj,
                                        self.xform.x(x), self.xform.y(y) )
                self.symbols.append(symid)
              if not inside:
                assert len(cpnts) == 0
                # previous point was outside;  need to find the intersection
                # then add the intersection point to cpnts with no symbol
                xx, yy = lineBoxIntersection( x, y,
                                   self.points[i-1][0], self.points[i-1][1],
                                   L, R, B, T,
                                   self.points[i-1][0], self.points[i-1][1] )
                cpnts.append( self.xform.x(xx) )
                cpnts.append( self.xform.y(yy) )
              cpnts.append( self.xform.x(x) )
              cpnts.append( self.xform.y(y) )
              inside = 1
            else:
              if inside:
                assert len(cpnts) > 0
                # add the intersection point to cpnts and close out this
                # cpnts list
                xx, yy = lineBoxIntersection( \
                                   self.points[i-1][0], self.points[i-1][1],
                                   x, y,
                                   L, R, B, T, x, y )
                cpnts.append( self.xform.x(xx) )
                cpnts.append( self.xform.y(yy) )
                idL.append( cpnts )
                cpnts = []
              else:
                # TODO: Currently, any two consecutive outside points that
                #       intersect the plot window are ignored.
                #       One could add a test that both points are within the
                #       x window or both are within the y window and add a
                #       single segment from one side to the other.
                pass
              inside = 0
            i = i + 1

          if len(cpnts) > 2:
            idL.append(cpnts)

          for cpnts in idL:
            cid = apply( canvas_obj.create_line, cpnts,
                         { 'fill':self.linetype.getColor(),
                           'dash':self.linetype.getStyle() } )
            self.canvas_ids.append(cid)

        else:
          w = 10*w
          h = 10*h
          cpnts = []
          for (x,y) in self.points:
            if abs(x - L) < w and abs(y - B) < h:
              if use_symbols.get():
                symid = self.linetype.draw( canvas_obj,
                                        self.xform.x(x), self.xform.y(y) )
                self.symbols.append(symid)
              cpnts.append( self.xform.x(x) )
              cpnts.append( self.xform.y(y) )
          if len(cpnts) > 2:
            cid = apply( canvas_obj.create_line, cpnts,
                         { 'fill':self.linetype.getColor(),
                           'dash':self.linetype.getStyle() } )
            self.canvas_ids.append(cid)

    def erase(self, canvas_obj):
        """
        Remove this data line from the canvas.
        """
        for cid in self.canvas_ids:
          canvas_obj.delete( cid )
        self.canvas_ids = []
        for sid in self.symbols:
          self.linetype.delete( canvas_obj, sid )
        self.symbols = []
        self.points = []


############################################################################

class DataBox:

    def __init__(self, xform, color='grey80'):
        self.xform = xform
        self.color = color
        self.canvas_id = None

    def draw(self, canvas_obj):
        if self.canvas_id == None:
          self.canvas_id = canvas_obj.create_line( \
                 self.xform.px(0), self.xform.py(0),
                 self.xform.size[0] - self.xform.inset[1], self.xform.py(0),
                 self.xform.size[0] - self.xform.inset[1], self.xform.inset[3],
                 self.xform.px(0), self.xform.inset[3],
                 self.xform.px(0), self.xform.py(0),
                 fill=self.color )
        else:
          canvas_obj.coords( self.canvas_id,
                self.xform.px(0), self.xform.py(0),
                self.xform.size[0] - self.xform.inset[1], self.xform.py(0),
                self.xform.size[0] - self.xform.inset[1], self.xform.inset[3],
                self.xform.px(0), self.xform.inset[3],
                self.xform.px(0), self.xform.py(0) )


############################################################################

class EntryDialog(tkSimpleDialog.Dialog):

    def __init__(self, master, title, initial_text, minval=None, maxval=None):
        self.result = None
        self.mytext = initial_text
        self.minv = minval
        self.maxv = maxval
        tkSimpleDialog.Dialog.__init__(self, master, title=title)

    def body(self, master):
        master.pack( padx=5, pady=5, fill=X, expand=YES )
        self.entry = Entry(master)
        self.entry.pack(fill=X, expand=YES)
        self.entry.insert(0,self.mytext)
        if self.minv != None and self.maxv != None:
          f = Frame(master) ; f.pack()
          Label(f,text="Min").pack( side=LEFT )
          self.minf = Entry(f)
          self.minf.insert(0,self.minv)
          self.minf.pack()
          f = Frame(master) ; f.pack()
          Label(f,text="Max").pack( side=LEFT )
          self.maxf = Entry(f)
          self.maxf.insert(0,self.maxv)
          self.maxf.pack()
        return self.entry # initial focus

    def apply(self):
        if self.minv != None and self.maxv != None:
          self.result = ( self.entry.get(), self.minf.get(), self.maxf.get() )
        else:
          self.result = self.entry.get()


############################################################################

class ShivCanvas(Canvas):

    def __init__(self, *args, **kwargs):

        apply( Canvas.__init__, (self,) + args, kwargs )

        self.save_width = kwargs.get('width',20)
        self.save_height = kwargs.get('height',10)

        self.xform = Transformer()
        self.xform2 = Transformer()
        self.xform.setCanvas( self.save_width, self.save_height )
        self.xform2.setCanvas( self.save_width, self.save_height )
        self.xform.setWorld( 0.0, 1.0, 0.0, 1.0 )
        self.xform2.setWorld( 0.0, 1.0, 0.0, 1.0 )
        self.xform2.same_limits = 1

        # this will catch window resize events
        self.bind( '<Configure>', self.config )

        self.bind( '<Button-1>', self.click )
        self.bind( '<Motion>', self.move )
        self.bind( '<ButtonRelease>', self.release )
        self.bind( '<Control-ButtonRelease>', self.releaseCtrl )
        self.bind( '<ButtonRelease-3>', self.rightclick )

        self.objs = []
        self.lines = []
        self.title = None

        self.xlabel_id = None
        self.xlabel_font = None
        self.xlabel_height = 15  # about the height of 12 point Helvetica
        self.force_xlabel = None

        self.objs.append( DataBox( self.xform ) )
        self.xaxis = Axis( Axis.BOTTOM_SIDE, self.xform, self )
        self.objs.append( self.xaxis )
        self.yaxis = Axis( Axis.LEFT_SIDE, self.xform, self )
        self.objs.append( self.yaxis )
        self.rhsaxis = Axis( Axis.RIGHT_SIDE, self.xform2, self )
        self.objs.append( self.rhsaxis )

        self.legend = Legend( self, self.xform )

        self.makeHoverSticks()

        self.down = None
        self.font_popup = {}  # maps strings to FontPopup instances

        # zoom history; 8-tuples, 4 each for world1 and world2
        self.zoomL = []

    def setHoverVariable(self, hover_variable):
        self.hovervar = hover_variable

    def resetInsets(self):
        w = self.yaxis.getSize()
        h = self.xaxis.getSize() + self.xlabel_height + 4
        r = 20
        if self.xaxis.getSize() > 18:
          # push the left/right inset out a little for bigger fonts
          r = int( 1.1 * float(r) * float(self.xaxis.getSize())/float(18) )
          if w < r: w = r
        # TODO: title height
        if rhs_axis.get():
          if r < self.rhsaxis.getSize():
            r = self.rhsaxis.getSize()
          self.xform.setInsets( w, r, h, 20 )
          self.xform2.setInsets( w, r,h, 20 )
        else:
          self.xform.setInsets( w, r, h, 20 )
          self.xform2.setInsets( w, r, h, 20 )

    def clear(self):
        for line in self.lines:
          line.erase(self)
        self.lines = []
        if self.title != None:
          self.delete( self.title )
        self.title = None
        self.legend.clear()

    def setTitle(self, title):
        if self.title != None:
          self.delete( self.title )
        self.title = self.create_text( \
                             self.xform.halfHorizontal(), 17, text=title )

    def setXLabel(self, label):
        if self.force_xlabel != None:
          label = self.force_xlabel
        if label == None: label = "Time"
        if self.xlabel_id == None:
          xhalf = self.xform.halfHorizontal()
          # TODO: adjust for font (the bigger the font, the more padding to add)
          off = self.xform.py(0) + self.xaxis.getSize() + 2
          self.xlabel_id = self.create_text( xhalf, off, text=label, anchor=N )
          if self.xlabel_font != None:
            fopt, self.xlabel_font = fontToString( self.xlabel_font )
            self.itemconfigure( self.xlabel_id, font=fopt )
        else:
          self.itemconfigure( self.xlabel_id, text=label )

    def addDataLine(self, dline):
        """
        Adds a DataLine object to the list of lines to draw on the canvas.
        Does not actually draw the line -- use the draw() method.
        """
        self.lines.append( dline )
        self.legend.addLine( dline )

    def refreshLegend(self):
        self.legend.refresh()

    def removeDataLine(self, dline):
        """
        Removes a DataLine object from the list of lines to draw.  The line
        is also erased from the canvas here.
        """
        newlines = []
        for dl in self.lines:
          if dl == dline:
            self.legend.removeLine(dline)
            dl.erase(self)
          else:
            newlines.append(dl)
        self.lines = newlines

    def draw(self, dline=None):
        self.resetInsets()
        for obj in self.objs:
          obj.draw(self)
        if dline == None:
          for line in self.lines:
            line.draw(self)
        else:
          dline.draw(self)
        if self.xlabel_id != None:
          # TODO: adjust for font (the bigger the font, the more space to add)
          off = self.xform.py(0) + self.xaxis.getSize() + 2
          self.coords( self.xlabel_id, self.xform.halfHorizontal(), off )
        self.legend.refresh()

    def printToFile(self, filename, landscape, fmt):
        """
        Uses Tkinter.Canvas's postscript method to output a postscript file.
        If the landscape variable is true, then rotate 90 will be turned on.
        """
        s = ""

        self.legend.canvasDraw()
        self.removeHoverSticks()

        if fmt == ".eps":
          if landscape: s = self.postscript( file=filename, rotate=1 )
          else:         s = self.postscript( file=filename )
        else:
          n,x = os.path.splitext( os.path.basename( filename ) )
          tmpeps = os.path.dirname( filename ) + '/.' + n + '.eps'
          if landscape: s = self.postscript( file=tmpeps, rotate=1 )
          else:         s = self.postscript( file=tmpeps )
          if not s:
            if fmt == ".png":
              # resolution 300 creates fairly high quality pictures; going from
              # 150 to 300 cost about twice the file size;
              # png256 means 256 colors, png16m means 16 million colors;  we
              # don't need high number of colors here, so we use png256
              # what is GraphicsAlphaBits?  I just copied it from a web site
              cmd = 'gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=png256' + \
                      ' -dGraphicsAlphaBits=4 -r300 -dEPSCrop ' + \
                      ' -sOutputFile="' + filename + '" "' + tmpeps + '"'
              fp = os.popen( cmd, 'r' )
              out = fp.read()
              xs = fp.close()
              if xs != None:
                s = 'eps -> png conversion failed: ' + cmd
              else:
                try: os.unlink( tmpeps )
                except: pass
            elif fmt == ".jpg":
              # choose resolution 150 kind of arbitrarily; produces similar
              # file sizes as png above
              cmd = 'gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=jpeg' + \
                      ' -r150 -dEPSCrop ' + \
                      ' -sOutputFile="' + filename + '" "' + tmpeps + '"'
              fp = os.popen( cmd, 'r' )
              out = fp.read()
              xs = fp.close()
              if xs != None:
                s = 'eps -> jpg conversion failed: ' + cmd
              else:
                try: os.unlink( tmpeps )
                except: pass
            else:
              s = "Unknown format: " + fmt

        self.legend.windowDraw()
        self.makeHoverSticks()
        return s

    def setLogX(self, value):
        self.xform.setLogX(value)
        self.xform2.setLogX(value)
    def setLogY(self, value):
        self.xform.setLogY(value)
        self.xform2.setLogY(value)
    def setScale(self, value):
        self.xform.setScale(value)
        self.xform2.setScale(value)

    def makeHoverSticks(self):
        # these create hovering tick marks that follow the curser position
        # but pinned to the left, right and bottom axes
        self.lstick = self.create_line( self.xform.px(0)-5, self.xform.py(0),
                                        self.xform.px(0)+5, self.xform.py(0),
                                        fill="grey", capstyle="round" )
        pw = self.xform.plotWidth()
        self.rstick = self.create_line( self.xform.px(pw)-5, self.xform.py(0),
                                        self.xform.px(pw)+5, self.xform.py(0),
                                        fill="grey", capstyle="round" )
        self.bstick = self.create_line( self.xform.px(0), self.xform.py(0)-5,
                                        self.xform.px(0), self.xform.py(0)+5,
                                        fill="grey", capstyle="round" )

    def removeHoverSticks(self):
        self.delete( self.lstick )
        self.delete( self.rstick )
        self.delete( self.bstick )

    MIN_CANVAS_PIXELS = 100

    def config(self, event):
        """
        Use this callback to catch window resize events.
        """
        if event.width != self.save_width or event.height != self.save_height:

          if event.width < ShivCanvas.MIN_CANVAS_PIXELS:
            self.save_width = ShivCanvas.MIN_CANVAS_PIXELS
          else:
            self.save_width = event.width
          if event.height < ShivCanvas.MIN_CANVAS_PIXELS:
            self.save_height = ShivCanvas.MIN_CANVAS_PIXELS
          else:
            self.save_height = event.height

          self.xform.setCanvas( self.save_width, self.save_height )
          self.xform2.setCanvas( self.save_width, self.save_height )

          self.draw()

    def click(self, event):
        if self.down != None:
          self.coords( self.rect, event.x, event.y, event.x+1, event.y+1 )
        else:
          self.rect = self.create_rectangle( \
                              event.x, event.y, event.x+1, event.y+1,
                              outline='grey80', fill='' )
        self.down = ( event.x, event.y )

    def move(self, event):
        if self.down != None:
          x = event.x
          if x == self.down[0]: x = x + 1
          y = event.y
          if y == self.down[1]: y = y + 1
          self.coords( self.rect, self.down[0], self.down[1], x, y )
        else:
          wy = self.xform.wy( event.y )
          wx = self.xform.wx( event.x )
          self.hovervar.set( "x=%.14e, y=%.14e" % (wx, wy) )
          # also adjust the hover line segments pinned to the axes
          self.coords( self.lstick, self.xform.px(0)-5, event.y,
                                    self.xform.px(0)+5, event.y )
          pw = self.xform.plotWidth()
          self.coords( self.rstick, self.xform.px(pw)-5, event.y,
                                    self.xform.px(pw)+5, event.y )
          self.coords( self.bstick, event.x, self.xform.py(0)+5,
                                    event.x, self.xform.py(0)-5 )

    def release(self, event): self.processRelease(event)

    def releaseCtrl(self, event): self.processRelease(event,1)

    def processRelease(self, event, ctrl=0):

        if self.down != None:

          self.delete( self.rect )
          minx = max( min( self.down[0], event.x ), 0 )
          maxx = min( max( self.down[0], event.x ), self.xform.size[0] )
          miny = min( max( self.down[1], event.y), self.xform.size[1] )
          maxy = max( min( self.down[1], event.y ), 0 )
          if maxx - minx > 20 or miny - maxy > 20:

            minwx = self.xform.wx(minx)
            maxwx = self.xform.wx(maxx)
            minwy = self.xform.wy(miny)
            maxwy = self.xform.wy(maxy)

            minwx2 = self.xform2.wx(minx)
            maxwx2 = self.xform2.wx(maxx)
            minwy2 = self.xform2.wy(miny)
            maxwy2 = self.xform2.wy(maxy)

            same_limits = 1

            if not ctrl and len(self.lines) > 0:

              # recompute limits based on data points within the selected box

              wboxL = None
              for dline in self.lines:
                if dline.axis == "left":
                  b = dline.rebox(minwx, maxwx, minwy, maxwy)
                  if b != None:
                    if wboxL == None:
                      wboxL = [ b[0], b[1], b[2], b[3] ]
                    else:
                      if b[0] < wboxL[0]: wboxL[0] = b[0]
                      if b[1] > wboxL[1]: wboxL[1] = b[1]
                      if b[2] < wboxL[2]: wboxL[2] = b[2]
                      if b[3] > wboxL[3]: wboxL[3] = b[3]

              have_right = 0
              wboxR = None
              for dline in self.lines:
                if dline.axis != "left":
                  have_right = 1
                  b = dline.rebox(minwx2, maxwx2, minwy2, maxwy2)
                  if b != None:
                    if wboxR == None:
                      wboxR = [ b[0], b[1], b[2], b[3] ]
                    else:
                      if b[0] < wboxR[0]: wboxR[0] = b[0]
                      if b[1] > wboxR[1]: wboxR[1] = b[1]
                      if b[2] < wboxR[2]: wboxR[2] = b[2]
                      if b[3] > wboxR[3]: wboxR[3] = b[3]

              if wboxL != None and wboxR == None:
                minwx, maxwx = adjustRange( wboxL[0], wboxL[1] )
                minwy, maxwy = adjustRange( wboxL[2], wboxL[3] )
                if have_right:
                  same_limits = 0
                else:
                  minwy2 = minwy ; maxwy2 = maxwy

              elif wboxL == None and wboxR != None:
                minwx, maxwx = adjustRange( wboxR[0], wboxR[1] )
                minwy2, maxwy2 = adjustRange( wboxR[2], wboxR[3] )
                same_limits = 0

              elif wboxL != None and wboxR != None:
                # use right hand X axis limits to determine combined X limits
                minwx = wboxL[0] ; maxwx = wboxL[1]
                if minwx > wboxR[0]: minwx = wboxR[0]
                if maxwx < wboxR[1]: maxwx = wboxR[1]

                same_limits = sameLimits( wboxL, wboxR )

                minwx, maxwx = adjustRange( minwx, maxwx )
                minwy, maxwy = adjustRange( wboxL[2], wboxL[3] )

                if same_limits:
                  minwy2 = minwy ; maxwy2 = maxwy
                else:
                  minwy2, maxwy2 = adjustRange( wboxR[2], wboxR[3] )

            L,R,B,T     = self.xform.world
            L2,R2,B2,T2 = self.xform2.world
            self.zoomL.append( (L,R,B,T,L2,R2,B2,T2) )

            self.xform.setWorld( minwx, maxwx, minwy, maxwy )
            self.xform2.setWorld( minwx, maxwx, minwy2, maxwy2 )

            self.xform2.same_limits = same_limits

            self.draw()

          self.down = None

    def activatePopup(self, key, event, labelstring=None):
        pu = self.font_popup.get( key, None )
        if pu == None:
          pu = FontPopup( self, self, key, add_label=labelstring )
          self.font_popup[key] = pu
        pu.postPopUp(event)

    def rightclick(self,event):
        L = self.xform.px(0)
        R = self.xform.px(self.xform.plotWidth())
        B = self.xform.py(0)
        T = self.xform.inset[3]
        if event.x < L:
          if event.y > T and event.y < B:
            self.activatePopup( "leftaxis", event,
                                labelstring="Set Tick Marks" )
        elif event.x > R:
          if event.y > T and event.y < B:
            self.activatePopup( "rightaxis", event,
                                labelstring="Set Tick Marks" )
        elif event.y < T:
          if event.x > L and event.x < R:
            self.activatePopup( "title", event, labelstring="Set Title" )
        elif event.y > B:
          if event.x > L and event.x < R:
            if self.xlabel_id != None:
              # if the mouse coordinates outside the xlabel bounding box then
              # activate the bottom axis popup
              bb = self.bbox( self.xlabel_id )
              if event.x < bb[0]-5 or event.x > bb[2]+5 or event.y < bb[1]-5:
                self.activatePopup( "bottomaxis", event,
                                    labelstring="Set Tick Marks" )
              else:
                self.activatePopup( "xlabel", event, labelstring="Set X Label" )
            else:
              self.activatePopup( "bottomaxis", event,
                                  labelstring="Set Tick Marks" )

    def changeFont(self, idstring, family=None, size=None, style=None):
        if idstring == "leftaxis"or idstring == "rightaxis":
          sz = 0
          if idstring == "leftaxis":
            self.yaxis.setTickFont( family=family, size=size, style=style )
            sz = self.yaxis.getFontHeight()
            if self.rhsaxis != None and rhs_axis.get() and \
               sz < self.rhsaxis.getFontHeight():
              sz = self.rhsaxis.getFontHeight()
          elif self.rhsaxis != None:
            self.rhsaxis.setTickFont( family=family, size=size, style=style )
            if rhs_axis.get():
              sz = self.rhsaxis.getFontHeight()
              if sz < self.yaxis.getFontHeight():
                sz = self.yaxis.getFontHeight()
          # offset the bottom axis a bit more for larger vertical axis fonts
          if sz > 14:
            off = int( 3.0 * float(sz)/float(14) )
            self.xaxis.setAdditionalOffset(off)
          else:
            self.xaxis.setAdditionalOffset(0)
        elif idstring == "title":
          pass
        elif idstring == "bottomaxis":
          self.xaxis.setTickFont( family=family, size=size, style=style )
        elif idstring == "xlabel":
          self.setXLabelFont( family=family, size=size, style=style )
        self.draw()

    def popupChoice(self, key, menu_key):
        if key == "xlabel":
          xlab = self.itemcget( self.xlabel_id, "text" )
          d = EntryDialog(self, "Set X Label", xlab)
          if d.result != None:
            self.force_xlabel = d.result
            self.setXLabel(d.result)
        elif key == "title":
          pass #print "magic: change title"
        elif key == "leftaxis" or key == "rightaxis" or key == "bottomaxis":
          if key == "leftaxis":
            ax = self.yaxis
            D1,D2,L,R = ax.xform.getWorld()
          elif key == "rightaxis":
            ax = self.rhsaxis
            D1,D2,L,R = ax.xform.getWorld()
          else:
            ax = self.xaxis
            L,R,D1,D2 = ax.xform.getWorld()
          tL, sL = ax.getTicks()
          txt = string.join( sL )
          d = EntryDialog(self, "Set Tick Labels", txt, str(L), str(R) )
          if d.result != None:
            ax.setTickLabels( d.result[0] )
            try:
              L = float(d.result[1])
              R = float(d.result[2])
            except:
              L = 0 ; R = 0
            if L < R:
              if key == "leftaxis":
                self.xform.forceWorld( D1, D2, L, R )
              elif key == "rightaxis":
                if self.rhsaxis != None:
                  self.xform2.forceWorld( D1, D2, L, R )
              else:
                self.xform.forceWorld( L, R, D1, D2 )
            self.draw()

    def setXLabelFont(self, family=None, size=None, style=None ):
        if self.xlabel_id != None:
          if self.xlabel_font == None:
            self.xlabel_font = fontToList(self.itemcget(self.xlabel_id, "font"))
          fopt, self.xlabel_font = fontToString( self.xlabel_font,
                                      family=family, size=size, style=style )
          self.itemconfigure( self.xlabel_id, font=fopt )
          fnt = fontInstance( self.xlabel_font )
          self.xlabel_height = fnt.metrics('ascent') + \
                               fnt.metrics('descent') + 4


############################################################################

class LineType:

    SOLID = None
    DASHED = (8,4)
    DOTTED = (1,2)
    linemap = { None:"solid", (8,4):"dash", (1,2):"dot" }

    CROSS = 0
    PLUS = 1
    SQUARE = 2
    TRIANGLE = 3
    DIAMOND = 4
    CIRCLE = 5
    FILLED_SQUARE = 6
    FILLED_TRIANGLE = 7
    FILLED_DIAMOND = 8
    FILLED_CIRCLE = 9
    shapemap = { 0:"cross", 1:"plus", 2:"square", 3:"triangle", 4:"diamond",
                 5:"circle", 6:"fillsquare", 7:"filltriangle", 8:"filldiamond",
                 9:"fillcircle" }

    def __init__(self, color, style, shape, size=8):
        self.color = color
        self.style = style
        self.shape = shape
        self.size = size
        self.refcount = 0

    def __str__(self):
        return "LineType(" + str(self.color) + "," + \
                             LineType.linemap[self.style] + "," + \
                             LineType.shapemap[self.shape] + ')'

    def getColor(self):  return self.color
    def getStyle(self):  return self.style

    def draw(self, canvas_obj, x, y, idL=None):
        """
        The coordinates are canvas units.  Returns a list of canvas ids.
        """
        d = int(self.size/2)
        if self.shape == LineType.CROSS:
          if idL == None:
            idL = []
            idL.append( canvas_obj.create_line( \
                        x-d,y-d, x+d,y+d, fill=self.color, capstyle="round" ) )
            idL.append( canvas_obj.create_line( \
                        x-d,y+d, x+d,y-d, fill=self.color, capstyle="round" ) )
          else:
            canvas_obj.coords( idL[0], x-d,y-d, x+d,y+d )
            canvas_obj.coords( idL[1], x-d,y+d, x+d,y-d )

        elif self.shape == LineType.PLUS:
          if idL == None:
            idL = []
            idL.append( canvas_obj.create_line( \
                        x-d,y, x+d,y, fill=self.color, capstyle="round" ) )
            idL.append( canvas_obj.create_line( \
                        x,y+d, x,y-d, fill=self.color, capstyle="round" ) )
          else:
            canvas_obj.coords( idL[0], x-d,y, x+d,y )
            canvas_obj.coords( idL[1], x,y+d, x,y-d )

        elif self.shape == LineType.SQUARE:
          if idL == None:
            idL = []
            idL.append( canvas_obj.create_rectangle( \
                        x-d,y-d, x+d,y+d, outline=self.color ) )
          else:
            canvas_obj.coords( idL[0], x-d,y-d, x+d,y+d )

        elif self.shape == LineType.TRIANGLE:
          if idL == None:
            idL = []
            idL.append( canvas_obj.create_polygon( \
                         x,y-d, x-d,y+d, x+d,y+d, outline=self.color,
                         fill='' ) )
          else:
            canvas_obj.coords( idL[0], x,y-d, x-d,y+d, x+d,y+d )

        elif self.shape == LineType.DIAMOND:
          if idL == None:
            idL = []
            idL.append( canvas_obj.create_polygon( \
                         x,y-d, x-d,y, x,y+d, x+d,y, outline=self.color,
                         fill='' ) )
          else:
            canvas_obj.coords( idL[0], x,y-d, x-d,y, x,y+d, x+d,y )

        elif self.shape == LineType.CIRCLE:
          if idL == None:
            idL = []
            idL.append( canvas_obj.create_oval( \
                         x-d,y-d, x+d,y+d, outline=self.color, fill='' ) )
          else:
            canvas_obj.coords( idL[0], x-d,y-d, x+d,y+d )

        elif self.shape == LineType.FILLED_SQUARE:
          if idL == None:
            idL = []
            idL.append( canvas_obj.create_rectangle( \
                         x-d,y-d, x+d,y+d, outline=self.color,
                         fill=self.color ) )
          else:
            canvas_obj.coords( idL[0], x-d,y-d, x+d,y+d )

        elif self.shape == LineType.FILLED_TRIANGLE:
          if idL == None:
            idL = []
            idL.append( canvas_obj.create_polygon( \
                         x,y-d, x-d,y+d, x+d,y+d, outline=self.color,
                         fill=self.color ) )
          else:
            canvas_obj.coords( idL[0], x,y-d, x-d,y+d, x+d,y+d )

        elif self.shape == LineType.FILLED_DIAMOND:
          if idL == None:
            idL = []
            idL.append( canvas_obj.create_polygon( \
                         x,y-d, x-d,y, x,y+d, x+d,y, outline=self.color,
                         fill=self.color ) )
          else:
            canvas_obj.coords( idL[0], x,y-d, x-d,y, x,y+d, x+d,y )

        elif self.shape == LineType.FILLED_CIRCLE:
          if idL == None:
            idL = []
            idL.append( canvas_obj.create_oval( \
                         x-d,y-d, x+d,y+d, outline=self.color,
                         fill=self.color ) )
          else:
            canvas_obj.coords( idL[0], x-d,y-d, x+d,y+d )

        else:
          assert 0, "oops!"
          pass

        return idL

    def delete(self, canvas_obj, idL):
        for i in idL:
          canvas_obj.delete(i)


class LineTypePool:

    def __init__(self):
        L = []
        L.append( LineType( "blue",  LineType.SOLID,  LineType.CROSS           ) )
        L.append( LineType( "red",   LineType.SOLID,  LineType.PLUS            ) )
        L.append( LineType( "green", LineType.SOLID,  LineType.SQUARE          ) )
        L.append( LineType( "black", LineType.SOLID,  LineType.TRIANGLE        ) )
        L.append( LineType( "blue",  LineType.DASHED, LineType.DIAMOND         ) )
        L.append( LineType( "red",   LineType.DASHED, LineType.CIRCLE          ) )
        L.append( LineType( "black", LineType.DASHED, LineType.FILLED_SQUARE   ) )
        L.append( LineType( "green", LineType.DASHED, LineType.FILLED_TRIANGLE ) )
        L.append( LineType( "red",   LineType.DOTTED, LineType.FILLED_DIAMOND  ) )
        L.append( LineType( "blue",  LineType.DOTTED, LineType.FILLED_CIRCLE   ) )
        L.append( LineType( "green", LineType.DOTTED, LineType.PLUS            ) )
        L.append( LineType( "black", LineType.DOTTED, LineType.CROSS           ) )
        L.append( LineType( "red",   LineType.DASHED, LineType.CROSS           ) )
        L.append( LineType( "blue",  LineType.DOTTED, LineType.PLUS            ) )
        self.pool = L
        self.specmap = {}  # maps LineSpec key to LineType object

    def choose(self, lskey):
        """
        Returns an unused line type (if possible).  If the lskey has been
        given a line type before, then that one is returned.
        """
        lt = None
        if self.specmap.has_key(lskey):
          lt = self.specmap[lskey]
        elif len(self.pool) > 0:
          lt = self.pool.pop(0)
        else:
          L = self.specmap.keys()
          L.sort()
          minref = self.specmap[ L[0] ].refcount
          for k in L:
            lt = self.specmap[k]
            if lt.refcount < minref: minref = lt.refcount
          for k in L:
            lt = self.specmap[k]
            if lt.refcount == minref:
              break
        self.specmap[ lskey ] = lt
        lt.refcount = lt.refcount + 1
        return lt

    def release(self, lskey):
        lt = self.specmap.get( lskey, None )
        if lt != None:
          lt.refcount = lt.refcount - 1
          if lt.refcount == 0:
            self.pool.append(lt)


############################################################################

class Legend:

    def __init__(self, canvas_obj, xform):

        self.canvas_obj = canvas_obj
        self.xform = xform
        self.URoffset = [ xform.inset[1] + 10, xform.inset[3] + 10 ]

        self.win = None
        self.dragbox = None
        self.lines = []  # list of [DataLine,Label]

    def addLine(self, dline):

        label = dline.label

        skiplabel = 0
        for dl in self.lines:
          if label == dl.label:
            skiplabel = 1
            break

        if not skiplabel:

          linestyle = dline.linetype

          bg = "white"
          if hasattr(dline,'axis') and dline.axis != "left" and \
             not dline.xform.same_limits:
            bg = "lightgrey"

          if self.win == None:
            self.frame = Frame( self.canvas_obj, borderwidth=0,
                                background="white" )
            self.frame.pack()
            self.win = self.canvas_obj.create_window( \
                         self.xform.size[0] - self.URoffset[0], self.URoffset[1],
                         anchor=NE, window=self.frame )
            self.bindobj(self.frame)

          df = Frame( self.frame, background=bg )
          df.pack( side=TOP, padx=2, fill=X )
          self.bindobj(df)
          can = Canvas( df, width=35, height=14, background='white' )
          can.pack( side=LEFT, padx=2, pady=0 )
          if linestyle.getStyle() == None:
            can.create_line( 2, 7, 34, 7,
                             fill=linestyle.getColor(), capstyle="round" )
          else:
            can.create_line( 2, 7, 34, 7, fill=linestyle.getColor(),
                             dash=linestyle.getStyle(), capstyle="round" )
          if use_symbols.get():
            linestyle.draw(can, 19, 7)
          self.bindobj(can)
          lbl = Label( df, text=label, background=bg, anchor=W )
          lbl.pack( fill=X )
          self.bindobj(lbl)

        self.lines.append( dline )

    def removeLine(self, dline):
        curlines = self.lines
        self.clear()
        for dl in curlines:
          if dl != dline:
            self.addLine(dl)

    def canvasDraw(self):
        """
        The Tkinter.Canvas.postscript() method does not seem to handle canvas
        windows very well.  This method will write the legend using strictly
        canvas objects so that the postscript() method will write the legend
        correctly.  The windowDraw() method should be called right after the
        postscript call to replace the legend with the windowed one (which
        supports the drag move operation).
        """
        if self.win != None:

          assert len(self.lines) > 0

          # get current legend window bounding box
          x, y, x2, y2 = self.canvas_obj.bbox( self.win )

          # clear window objects
          self.frame.destroy()
          self.canvas_obj.delete( self.win )
          self.win = None
          self.frame = None

          # use a white rectangle to cover any graphs under the legend
          self.wids = []
          self.wids.append( self.canvas_obj.create_rectangle( \
                            x, y, x2, y2, outline='white', fill='white' ) )

          # adjust (x,y) to first line
          x = x + 3
          lineheight = 20  # this value seems to work well
          y = y + lineheight/2

          self.wLids = []
          for dline in self.lines:

            linestyle = dline.linetype
            label = dline.label

            # draw the line, symbol and label
            if linestyle.getStyle() == None:
              self.wids.append( \
                          self.canvas_obj.create_line( x, y, x+30, y,
                          fill=linestyle.getColor(), capstyle="round" ) )
            else:
              self.wids.append( \
                          self.canvas_obj.create_line( x, y, x+30, y,
                          fill=linestyle.getColor(),
                          dash=linestyle.getStyle(), capstyle="round" ) )
            if use_symbols.get():
              self.wLids.append( linestyle.draw(self.canvas_obj, x+15, y) )
            self.wids.append( \
                 self.canvas_obj.create_text( x+35, y, text=label, anchor=W ) )

            # bump the y value by the line height for the next label
            y = y + lineheight

    def windowDraw(self):
        """
        Replaces the canvas legend with a windowed one.  Complements the
        canvasDraw() method.
        """
        if len(self.lines) > 0:

          # remove the canvas objects
          for cid in self.wids:
            self.canvas_obj.delete( cid )
          for cidL in self.wLids:
            for cid in cidL:
              self.canvas_obj.delete( cid )

          # put back the windowed legend
          L = self.lines
          self.lines = []
          for dline in L:
            self.addLine(dline)

    def clear(self):
        if self.win != None:
          self.frame.destroy()
          self.canvas_obj.delete( self.win )
          self.win = None
          self.frame = None
        self.lines = []

    def refresh(self):
        if self.win != None:
          curlines = self.lines
          self.clear()
          for dl in curlines:
            self.addLine(dl)
          self.canvas_obj.coords( self.win,
                                  self.xform.size[0] - self.URoffset[0],
                                  self.URoffset[1] )

    def bindobj(self, obj):
        obj.bind( '<Button-1>', self.click )
        obj.bind( '<Motion>', self.move )
        obj.bind( '<ButtonRelease>', self.release )

    def click(self, event):
        self.clickx = event.x
        self.clicky = event.y
        self.dragbox = self.canvas_obj.create_rectangle( \
              self.xform.size[0] - self.URoffset[0] - \
                                           self.frame.winfo_width() - 1,
              self.URoffset[1] - 1,
              self.xform.size[0] - self.URoffset[0] + 1,
              self.URoffset[1] + self.frame.winfo_height() + 1,
              width=2, outline="red" )

    def move(self, event):
        if self.dragbox != None:
          dx = self.clickx - event.x
          dy = self.clicky - event.y
          self.canvas_obj.coords( self.dragbox,
                 self.xform.size[0] - self.URoffset[0] - \
                                             self.frame.winfo_width() - dx - 1,
                 self.URoffset[1] - dy - 1,
                 self.xform.size[0] - self.URoffset[0] - dx + 1,
                 self.URoffset[1] + self.frame.winfo_height() - dy + 1 )

    def release(self, event):
        if self.dragbox != None:
          dx = self.clickx - event.x
          dy = self.clicky - event.y
          self.URoffset[0] = self.URoffset[0] + dx
          self.URoffset[1] = self.URoffset[1] - dy
          self.canvas_obj.delete(self.dragbox)
          self.canvas_obj.coords( self.win,
                                  self.xform.size[0] - self.URoffset[0],
                                  self.URoffset[1] )
          self.dragbox = None


############################################################################

class StatusBar(Frame):

    def __init__(self, *args, **kwargs):

        apply( Frame.__init__, (self,) + args, kwargs )

        self.file_buttons = []
        self.popup_callback = None

    def setPopupCallback(self, callback):
        self.popup_callback = callback

    def addZoomResetButton(self, callback):

        btn = Button( self, text="Zoom Reset", padx=5 )
        btn.bind( '<ButtonRelease>', callback )
        btn.pack(side=RIGHT)

    def addRereadButton(self, callback):

        btn = Button( self, text="Reread", padx=5 )
        btn.bind( '<ButtonRelease>', callback )
        btn.pack(side=RIGHT)

    def addValueLabel(self, string_variable):

        lbl = Label( self, textvariable=string_variable, padx=10, width=30 )
        lbl.pack( side=RIGHT, anchor=W, fill=X, expand=YES )

    def addFileButton(self, filename, callback):

        btn = Button( self, text=filename, anchor="w", padx=5 )
        btn.bind( '<ButtonRelease>', callback )
        btn.pack( side=LEFT )
        self.file_buttons.append( btn )
        if self.popup_callback != None:
          btn.bind( '<ButtonRelease-3>', self.popup_callback )
          btn.bind( '<Control-ButtonRelease>', self.popup_callback )

    def removeFileButton(self, fname_id):
        newlist = []
        for btn in self.file_buttons:
          if btn.cget('text') == fname_id:
            btn.destroy()
          else:
            newlist.append( btn )
        self.file_buttons = newlist

    def clearFileButtons(self):

        for btn in self.file_buttons:
          btn.destroy()
        self.file_buttons = []


############################################################################

class FileRemovePopup:

    def __init__(self, dataman, statusbar):
        self.dataman = dataman
        self.statusbar = statusbar
        self.menu = None
        self.stringid = None
        self.menu = Menu( statusbar, tearoff=0 )
        self.menu.add_command( label="Remove", command=self.rmFile )

    def postPopUp(self, event):
        self.stringid = event.widget.cget( 'text' )
        self.menu.entryconfigure( 0, label='Remove "' + self.stringid + '"' )
        self.menu.post( event.widget.winfo_rootx() + event.x,
                        event.widget.winfo_rooty() + event.y )
        # these seemed to be needed at one point but now cause a
        # problem on windows
        #self.menu.grab_set()
        #self.menu.focus_set()

    def rmFile(self):
        assert self.stringid != None
        self.statusbar.removeFileButton( self.stringid )
        self.dataman.removeFileData( self.stringid )


class FontPopup:

    def __init__(self, parent, listener, key, add_label=None):
        self.listener = listener
        self.key = key
        self.add_label = add_label

        self.menu = Menu( parent, tearoff=0 )

        self.family_menu = Menu( self.menu, tearoff=0 )
        self.menu.add_cascade( label="Font", menu=self.family_menu )
        for ff in font_families:
          fcn = self._make_family_fcn(ff)
          self.family_menu.add_command( label=ff, command=fcn )

        self.size_menu = Menu( self.menu, tearoff=0 )
        self.menu.add_cascade( label="Size", menu=self.size_menu )
        for sz in [ "8", "10", "12", "14", "16", "18", "20", "22", "24", "32" ]:
          fcn = self._make_size_fcn(sz)
          self.size_menu.add_command( label=sz, command=fcn )

        self.style_menu = Menu( self.menu, tearoff=0 )
        self.menu.add_cascade( label="Style", menu=self.style_menu )
        for st in [ "normal", "bold", "roman", "italic", "underline" ]:
          fcn = self._make_style_fcn(st)
          self.style_menu.add_command( label=st, command=fcn )

        if add_label != None:
          self.menu.add_separator()
          self.menu.add_command( label=add_label, command=self.labelCmd )

    def postPopUp(self, event):
        self.menu.post( event.widget.winfo_rootx() + event.x,
                        event.widget.winfo_rooty() + event.y )
        # these seemed to be needed at one point but now cause a
        # problem on windows
        #self.menu.grab_set()
        #self.menu.focus_set()

    def choice(self, family=None, size=None, style=None):
        if family != None:
          self.listener.changeFont( self.key, family=family )
        elif size != None:
          self.listener.changeFont( self.key, size=size )
        elif style != None:
          self.listener.changeFont( self.key, style=style )

    def _make_family_fcn(self, s):
        return lambda: self.choice( family=s )

    def _make_size_fcn(self, s):
        return lambda: self.choice( size=s )

    def _make_style_fcn(self, s):
        return lambda: self.choice( style=s )

    def labelCmd(self):
        self.listener.popupChoice( self.key, self.add_label )


############################################################################

def readPrefs():

    try:
      fn = os.path.expanduser(r'~')
      if fn == r'~': fn = ''
    except Exception, e:
      fn = ''
    if fn and not os.name in ['nt', 'dos', 'mac', 'os2']:
      fn = os.path.join( fn, '.shivrc' )

    if fn:
      try:
        fp = open( fn, "r" )
      except Exception, e:
        fp = None
      if fp != None:
        for line in fp.readlines():
          lineL = []
          for s in string.split( line, "=" ):
            lineL.append( string.strip(s) )
          if len(lineL) == 2:
            if lineL[0] == "USE LINE SYMBOLS":
              if lineL[1] == "true": use_symbols.set(1)
              else:                  use_symbols.set(0)
            elif lineL[0] == "AUTO ZOOM RESET":
              if lineL[1] == "true": auto_zoom.set(1)
              else:                  auto_zoom.set(0)
            elif lineL[0] == "USE RIGHT HAND AXIS":
              if lineL[1] == "true": rhs_axis.set(1)
              else:                  rhs_axis.set(0)
        fp.close()


def writePrefs():

    try:
      fn = os.path.expanduser(r'~')
      if fn == r'~': fn = ''
    except Exception, e:
      fn = ''
    if fn and not os.name in ['nt', 'dos', 'mac', 'os2']:
      fn = os.path.join( fn, '.shivrc' )

    if fn:
      try:
        fp = open( fn, "w" )
      except Exception, e:
        fp = None
      if fp != None:
        if use_symbols.get(): fp.write( "USE LINE SYMBOLS = true\n" )
        else:                 fp.write( "USE LINE SYMBOLS = false\n" )
        if auto_zoom.get(): fp.write( "AUTO ZOOM RESET = true\n" )
        else:               fp.write( "AUTO ZOOM RESET = false\n" )
        if rhs_axis.get(): fp.write( "USE RIGHT HAND AXIS = true\n" )
        else:              fp.write( "USE RIGHT HAND AXIS = false\n" )
        fp.close()


############################################################################

try:
  root = Tk()
except TclError, e:
  print "*** shiv: error: could not initialize Tk: " + str(e)
  sys.exit(1)
root.title('shiv')

use_symbols = IntVar()
use_symbols.set(1)

auto_zoom = IntVar()
auto_zoom.set(1)

rhs_axis = IntVar()
rhs_axis.set(0)

plot_clip = IntVar()
plot_clip.set(0)

readPrefs()

data_view = IntVar()
data_view.set(DATAVIEW_HISTORY)

menu = ShivMenu( root, borderwidth=2, relief=RAISED )
menu.pack( side=TOP, fill=X )

statusbar = StatusBar( root, borderwidth=2, relief=RIDGE )
statusbar.pack( side=BOTTOM, fill=X )

# pack the canvas after the menu and status bar so it will shrink first
canv = ShivCanvas( root, borderwidth=0, width=600, height=350,
                         background='white' )
canv.pack( fill=BOTH, expand=YES )

dataman = DataManager(canv)
menu.setWidgets(dataman, statusbar)

statusbar.addZoomResetButton( lambda event, dm=dataman: dm.refreshZoom() )
statusbar.addRereadButton( lambda event, dm=dataman: dm.rereadData() )

popup = FileRemovePopup( dataman, statusbar )
statusbar.setPopupCallback( popup.postPopUp )

hoverval = StringVar()
statusbar.addValueLabel( hoverval )
canv.setHoverVariable( hoverval )
hoverval.set( " " )

if len(args) > 0:
  fileLoad( args, dataman, statusbar )

font_families = []
try:
  import tkFont
  D = {}
  for ff in tkFont.families():
    D[ string.lower(ff) ] = ff
  # filter the list to include the more common and useful fonts
  for ff in [ 'Nimbus Mono L', 'Century Schoolbook L', 'Courier',
              'Bitstream Vera Sans', 'Nimbus Roman No9 L', 'Utopia',
              'Bitstream Vera Serif', 'Courier New', 'Helvetica', 'Arial',
              'Fixed', 'Times New Roman', 'Times', 'Comic Sans MS', 'Fixedsys',
              'MS Sans Serif', 'MS Serif', 'System', 'Verdana' ]:
    ff = string.lower(ff)
    if D.has_key(ff):
      font_families.append( D[ff] )
    font_families.sort()
except:
  font_families = []

root.mainloop()
